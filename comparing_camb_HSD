import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import numpy as np
import logging
from typing import List, Dict, Any, Optional
from scipy.interpolate import interp1d

# --- Fixed cosmological parameters from Planck 2018 ---
# --- Using CAMB units ---
c_in_km_s = 299_792.458
h = 0.6756
H0 = 100*h/c_in_km_s
rho_cr = 3*H0**2
omega_c = 0.12/h**2
omega_b = 0.022/h**2
omega_phot = 2.47e-5/h**2
omega_massless_nu = 3*(7/8)*(4/11)**(4/3)*omega_phot
omega_r = omega_phot + omega_massless_nu
omega_de = 1 - omega_c - omega_b - omega_r
omega_de_target = omega_de
omega_c_target = omega_c

# -- For Camb --
import camb

h_main, omegabh2_main, omegach2_main = 0.6756, 0.022, 0.120
As_main, ns_main = 2.1e-9, 0.965

# -- DESI central values ---
w0_desi = -0.727
wa_desi = -1.05

# -- Global simulation parameters ---
global_alpha = 1
a_ini = 1e-5 # Fixed for CAMB 
a_end = 1.0
n_steps = 50000
phi_i_base = 10.5
phi_prime_i_base = 0.28
#default_guesses = {'V0': [rho_cr * omega_de_target * 0.8, rho_cr * omega_de_target * 1.2]}
potential_flag = 5 
default_guesses = {'A':  [rho_cr * omega_de_target * 0.8, rho_cr * omega_de_target * 1.2]}
inverse_power = 9

# -- Results from HDS (ODEINT-Based) --

from HDSSolver import global_alpha, find_all_phantom_crossings, find_w_phi_critical_points, run_full_simulation

results_HDS = run_full_simulation(
                    potential_flag=potential_flag, # CAMB inverse power law
                    params_vector_to_shoot={'A': True, 'B': inverse_power},
                    a_ini=a_ini, a_end=a_end, n_steps=n_steps,
                    phi_i=phi_i_base, phi_prime_i=phi_prime_i_base,
                    default_guesses=default_guesses
                )

# -- Results from CAMB --
params = camb.set_params(
        H0=100 * h_main, ombh2=omegabh2_main, omch2=omegach2_main, TCMB=2.7255,
        dark_energy_model='HybridQuintessence',
        phi_i=phi_i_base, phi_prime_i=phi_prime_i_base, alpha=global_alpha, potential_type=3, beta=inverse_power,
        omnuh2=0, num_nu_massless=3.044, num_nu_massive=0,
        nu_mass_degeneracies=[0], nu_mass_numbers=[0],
        As=As_main, ns=ns_main, tau=0.0544,
        YHe=0.246, WantTransfer=True
    )
params.NonLinear = camb.model.NonLinear_none

results_camb = camb.get_results(params)

scale_factor_arr = results_HDS['a'] # using same array for both results

rhos = results_camb.get_background_densities(scale_factor_arr)
#   H was set to a*H(z), and then H_curly was set to a*H again (=> a^2 H).
#   h_of_z already returns H(z). Conformal Hubble is H_curly = a*H.
H = results_camb.h_of_z(1 / scale_factor_arr - 1)
H_curly = scale_factor_arr * H
_, w_de = results_camb.get_dark_energy_rho_w(scale_factor_arr)
rho_de = rhos['de']
rho_cdm = rhos['cdm'] 
rho_b = rhos['baryon']
rho_phot = rhos['photon']
rho_nu = rhos['neutrino']
rho_rad = rho_phot + rho_nu

de = results_camb.Params.DarkEnergy

phi_interpolator = interp1d(de.sampled_a, de.phi_a, bounds_error=False, fill_value="extrapolate")
phi_prime_interpolator = interp1d(de.sampled_a, de.phidot_a, bounds_error=False, fill_value="extrapolate")

phi = phi_interpolator(scale_factor_arr)
phi_prime = phi_prime_interpolator(scale_factor_arr)

coupling_term = global_alpha * phi_prime * rho_cdm / (phi * 3 * H_curly * rho_de)
w_eff = w_de + coupling_term
#   delta_dm used physical-rho scaling (a^-3) on CAMB arrays that are in a^4*rho units.
#   In a^4*rho units, the non-interacting CDM baseline scales as ~a.
delta_dm = -rho_cdm[0] * (scale_factor_arr / scale_factor_arr[0]) + rho_cdm
w_ds = w_de / (1-delta_dm/rho_de)

# Legacy direct full-array prints removed in favor of structured comparison below.

results_camb_dict = {
    'a': scale_factor_arr,
    'phi': phi,
    'phi_prime': phi_prime,
    'rho_de': rho_de,
    'rho_cdm': rho_cdm,
    'rho_b': rho_b,
    'rho_rad': rho_rad,
    'H': H,
    'H_curly': H_curly,
    'w_phi': w_de,
    'w_eff': w_eff,
    'w_ds': w_ds,
    'potential_object': 'Constant Potential (CAMB)',
    'initial_conditions': {
        'a_ini': a_ini,
        'phi_i': phi_i_base,
        'phi_prime_i': phi_prime_i_base
    }
}

def compare_all_compatible_results(
    results_camb: Dict[str, Any] = results_camb_dict,
    results_hds: Dict[str, Any] = results_HDS,
    top_n: int = 12
) -> List[Dict[str, Any]]:
    """
    Compares all CAMB/HDS quantities that can be matched and ranks incompatibilities.
    """
    comparable_pairs = [
        ('a', 'a'),
        ('phi', 'phi'),
        ('phi_prime', 'phi_prime'),
        # BEFORE:
        #   CAMB a^4*rho arrays were compared against HDS physical-rho arrays.
        # WHY THIS CHANGE:
        #   Compare in the same density convention to remove pure unit mismatch.
        ('rho_de', 'rho_phi_a4'),
        ('rho_cdm', 'rho_dm_a4'),
        ('rho_b', 'rho_b_a4'),
        ('rho_rad', 'rho_r_a4'),
        ('H_curly', 'H_curly'),
        ('w_phi', 'w_phi'),
        ('w_eff', 'w_eff'),
        ('w_ds', 'w_ds'),
    ]

    eps = 1e-30
    rows: List[Dict[str, Any]] = []

    print("\n=== CAMB vs HDS Comparable Results ===")
    for camb_key, hds_key in comparable_pairs:
        if camb_key not in results_camb:
            print(f"[SKIP] CAMB missing key: {camb_key}")
            continue
        if hds_key not in results_hds:
            print(f"[SKIP] HDS missing key: {hds_key}")
            continue

        camb_vals = np.asarray(results_camb[camb_key])
        hds_vals = np.asarray(results_hds[hds_key])

        if camb_vals.shape != hds_vals.shape:
            print(f"[SKIP] {camb_key} <-> {hds_key}: shape mismatch {camb_vals.shape} vs {hds_vals.shape}")
            continue
        if not (np.issubdtype(camb_vals.dtype, np.number) and np.issubdtype(hds_vals.dtype, np.number)):
            print(f"[SKIP] {camb_key} <-> {hds_key}: non-numeric")
            continue

        mask = np.isfinite(camb_vals) & np.isfinite(hds_vals)
        if not np.any(mask):
            print(f"[SKIP] {camb_key} <-> {hds_key}: no finite overlap")
            continue

        c = camb_vals[mask]
        h = hds_vals[mask]
        abs_diff = np.abs(h - c)
        rel_diff = 100.0 * abs_diff / (np.abs(c) + eps)

        mean_abs = float(np.mean(abs_diff))
        max_abs = float(np.max(abs_diff))
        mean_rel = float(np.mean(rel_diff))
        p95_rel = float(np.percentile(rel_diff, 95))
        max_rel = float(np.max(rel_diff))

        # Heuristic score: persistent mismatch + tail mismatch.
        score = mean_rel + 0.25 * p95_rel

        rows.append({
            'pair': f'{camb_key} <-> {hds_key}',
            'mean_abs': mean_abs,
            'max_abs': max_abs,
            'mean_rel_pct': mean_rel,
            'p95_rel_pct': p95_rel,
            'max_rel_pct': max_rel,
            'score': score,
        })

        n = min(3, c.size)
        print(f"\n[{camb_key} <-> {hds_key}]")
        print(f"  CAMB sample: {c[:n]}")
        print(f"  HDS  sample: {h[:n]}")
        print(
            f"  mean|Δ|={mean_abs:.3e}, max|Δ|={max_abs:.3e}, "
            f"mean rel={mean_rel:.3e}%, p95 rel={p95_rel:.3e}%, max rel={max_rel:.3e}%"
        )

    rows.sort(key=lambda r: r['score'], reverse=True)

    print("\n=== Most Incompatible Pairs (ranked) ===")
    if not rows:
        print("No compatible numeric pairs found.")
        return rows

    for i, row in enumerate(rows[:top_n], start=1):
        print(
            f"{i:>2}. {row['pair']}: "
            f"score={row['score']:.3e}, mean rel={row['mean_rel_pct']:.3e}%, "
            f"p95 rel={row['p95_rel_pct']:.3e}%, max rel={row['max_rel_pct']:.3e}%"
        )
    return rows

# -- Plotting --

def compare_eos(results_camb: Dict[str, Any] = results_camb_dict,
                 results_hds: Dict[str, Any] = results_HDS, 
                 xlim: Optional[List[float]] = None,
                 ylim: Optional[List[float]] = None,
                 use_redshift=True,
                 show_initial_parameters=True,
                 ) -> None:
    """
    Plots w_phi and w_ds from both CAMB and HDS on the same axes.
    By default, uses redshift and xlim = [0, 3].
    """
    logging.info("--- Plotting Results ---")
    fig, ax = plt.subplots(figsize=(12, 7))
    
    if use_redshift:
        x_data = 1 / results_hds['a'] - 1
        xlabel = "Redshift (z)"
        ax.invert_xaxis()
        if xlim is None:
            xlim = [0, 3]
    else:
        x_data = results_hds['a']
        xlabel = "Scale Factor (a)"

    ax.plot(x_data, results_hds['w_phi'], color='#1f77b4', linestyle='-', linewidth=2.0, label=r'HDS $w_{\phi}$')
    ax.plot(x_data, results_hds['w_ds'], color='#1f77b4', linestyle='--', linewidth=2.0, label=r'HDS $w_{ds}$')
    ax.plot(x_data, results_camb['w_phi'], color='#d62728', linestyle='-', linewidth=2.0, label=r'CAMB $w_{\phi}$')
    ax.plot(x_data, results_camb['w_ds'], color='#d62728', linestyle='--', linewidth=2.0, label=r'CAMB $w_{ds}$')
    ax.axhline(-1, color='black', linestyle=':', linewidth=1, alpha=0.8, label='Phantom Divide ($w=-1$)')

    if xlim: 
        ax.set_xlim(xlim)
    if ylim: 
        ax.set_ylim(ylim)
    else:
        ax.set_ylim(-1.5, 1.2)

    ax.set_xlabel(xlabel)
    ax.set_ylabel("Equation of State (w)")

    if not use_redshift: 
        ax.set_xscale('log')
    ax.grid(True, which='both', linestyle='--', linewidth=0.5)

    handles, labels = ax.get_legend_handles_labels()
    if show_initial_parameters:
        ic = results_hds['initial_conditions']
        ic_text = (
            f"Initial Conditions:\n"
            fr"$a_i = {ic['a_ini']:.1e}$"
            f"\n"
            fr"$\phi_i = {ic['phi_i']}$"
            f"\n"
            fr"$\phi'_i = {ic['phi_prime_i']} [Mpc^{-1}]$"
            f"\n"
            fr"$\alpha={global_alpha}$"
        )
        extra = Rectangle((0, 0), 1, 1, fc="w", fill=False, edgecolor='none', linewidth=0)
        handles.append(extra)
        labels.append(ic_text)

    ax.legend(handles, labels, loc='best', fontsize=9, framealpha=0.9)

    plt.title('Comparison of Dark Energy Equation of State: HDS vs CAMB', fontsize=14)
    plt.tight_layout()

def plot_relative_error(results_camb: Dict[str, Any],
                        results_hds: Dict[str, Any],
                        use_log_scale_y: bool = True,
                        quantities_to_compare: List[str] = ['w_eff', 'w_phi']) -> None:
    """
    Plots the relative error between HDS and CAMB results for a list of specified quantities.
    Relative Error = |(HDS - CAMB) / CAMB| * 100 (%)
    
    Args:
        results_camb: Dictionary of CAMB results.
        results_hds: Dictionary of HDS results.
        use_log_scale_y: Whether to use log scale for the y-axis.
        quantities_to_compare: List of keys to compare (e.g., ['w_eff', 'w_phi', 'phi', 'phi_prime']).
    """
    
    # Extract scale factor
    if 'a' not in results_hds:
        print("Error: Scale factor 'a' not found in results_hds.")
        return
    a = results_hds['a']
    
    # Setup Plot
    fig, ax = plt.subplots(figsize=(10, 6))
    epsilon = 1e-30  # To avoid division by zero
    
    plotted_any = False
    
    # Iterate over the requested quantities
    for qty in quantities_to_compare:
        # Check if quantity exists in both dictionaries
        if qty not in results_hds:
            print(f"Warning: Quantity '{qty}' not found in HDS results. Skipping.")
            continue
        if qty not in results_camb:
            print(f"Warning: Quantity '{qty}' not found in CAMB results. Skipping.")
            continue
            
        # Convert to numpy arrays to ensure element-wise operations work
        val_hds = np.array(results_hds[qty])
        val_camb = np.array(results_camb[qty])
        
        # Check for shape mismatch
        if val_hds.shape != val_camb.shape:
            print(f"Warning: Shape mismatch for '{qty}': HDS {val_hds.shape} vs CAMB {val_camb.shape}. Skipping.")
            continue
            
        # Calculate Relative Error (%)
        # Formula: |(HDS - CAMB) / CAMB| * 100
        rel_error = np.abs((val_hds - val_camb) / (val_camb + epsilon)) * 100
        
        # Create a formatted label for the legend
        # Tries to format variable names with underscores as LaTeX subscripts
        if '_' in qty:
            base, sub = qty.split('_', 1)
            label = fr"Error ${base}_{{{sub}}}$ (%)"
        else:
            label = f"Error ${qty}$ (%)"
            
        ax.plot(a, rel_error, label=label, linewidth=1.5)
        plotted_any = True
    
    if not plotted_any:
        plt.close(fig)
        print("No valid quantities were found to plot.")
        return
    
    # Styling
    ax.set_xlabel("Scale Factor (a)", fontsize=12)
    ax.set_ylabel(r"Relative Error (%) $\left| \frac{HDS - CAMB}{CAMB} \right| \times 100$", fontsize=12)
    
    # Create a title listing the quantities (truncated if too long)
    title_str = ", ".join(quantities_to_compare)
    if len(title_str) > 40:
        title_str = title_str[:37] + "..."
    ax.set_title(f"Relative Error: {title_str}", fontsize=14)
    
    ax.set_xscale('log')
    if use_log_scale_y:
        ax.set_yscale('log')
        
    ax.grid(True, which="both", ls="--", alpha=0.5)
    ax.legend(fontsize=12)
    
    plt.tight_layout()

def compare_results(results_camb: Dict[str, Any],
                    results_hds: Dict[str, Any], 
                    quantities: List[str] = ['w_phi', 'w_eff'],
                    show_phantom_crossings=False, 
                    show_critical_points=False,
                    xlim: Optional[List[float]] = None,
                    ylim: Optional[List[float]] = None,
                    use_redshift=False,
                    show_initial_parameters=True,
                    show_phantom_phase=False,
                    normalize_non_w: bool = True
                    ) -> None:
    """
    Plots specified quantities from both CAMB and HDS results for comparison.
    
    Args:
        quantities: List of keys to plot. e.g. ['w_phi', 'w_eff'] or ['phi', 'phi_prime'].
                    If quantities don't start with 'w', they are optionally normalized.
        normalize_non_w: If True, quantities not starting with 'w' are divided by their initial value.
    """
    logging.info(f"--- Plotting Results: {quantities} ---")
    
    # Determine if we are plotting Equations of State (to decide on grid lines/phases)
    plotting_w = any(q.startswith('w') for q in quantities)
    
    # --- Setup Figure ---
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7), sharey=True)
    
    # --- Setup X-axis ---
    if use_redshift:
        # Check if 'a' exists, handle potential division by zero
        a_hds = np.array(results_hds['a'])
        x_data = 1 / a_hds - 1
        xlabel = "Redshift (z)"
        ax1.invert_xaxis()
        ax2.invert_xaxis() 
    else:
        x_data = results_hds['a']
        xlabel = "Scale Factor (a)"
    
    # --- Style Definitions ---
    # Define styles for common variables to maintain consistency
    styles = {
        'w_phi':   {'color': '#1f77b4', 'ls': '-', 'label': r'$w_{\phi}$ (DE)'},
        'w_eff':   {'color': '#ff7f0e', 'ls': '--', 'label': r'$w_{eff}$'},
        'phi':     {'color': '#2ca02c', 'ls': '-', 'label': r'$\phi$'},
        'phi_prime': {'color': '#d62728', 'ls': '-.', 'label': r'$\phi^{\prime}$'},
        'rho_dm':  {'color': '#9467bd', 'ls': ':', 'label': r'$\rho_{dm}$'},
    }
    
    # Fallback color cycle for unknown quantities
    color_cycle = plt.rcParams['axes.prop_cycle'].by_key()['color']

    # --- Plotting Loop ---
    for ax, res, title in zip([ax1, ax2], [results_hds, results_camb], ['HDS Results', 'CAMB Results']):
        ax.set_title(title)
        
        for i, qty in enumerate(quantities):
            if qty not in res:
                logging.warning(f"Quantity {qty} not found in {title}")
                continue
            
            data = np.array(res[qty])
            
            # --- Normalization Logic ---
            # If it's not an EOS parameter and normalization is requested
            is_w = qty.startswith('w')
            is_normalized = False
            
            if not is_w and normalize_non_w:
                norm_factor = data[0] if data[0] != 0 else 1.0
                if norm_factor != 1.0:
                    data = data / norm_factor
                    is_normalized = True
            
            # --- Styling ---
            if qty in styles:
                style = styles[qty].copy()
                if is_normalized:
                    style['label'] = style['label'] + r' $/ \cdot_0$'
            else:
                # Generic style for unknown variables
                style = {
                    'color': color_cycle[i % len(color_cycle)], 
                    'ls': '-', 
                    'label': qty + (r' $/ \cdot_0$' if is_normalized else '')
                }

            # Plot
            ax.plot(x_data, data, label=style['label'], color=style['color'], linestyle=style['ls'], linewidth=2)

            # --- Special Features for w_phi ---
            if qty == 'w_phi' and show_critical_points:
                crit_indices = find_w_phi_critical_points(data)
                if len(crit_indices) > 0:
                    ax.scatter(x_data[crit_indices], data[crit_indices], 
                               marker='o', s=50, facecolors='none', edgecolors='green',
                               zorder=5) # No label to avoid clutter

    # --- Phantom Divide & Phase (Only if plotting w) ---
    if plotting_w:
        for ax, res in zip([ax1, ax2], [results_hds, results_camb]):
            ax.axhline(-1, color='gray', linestyle='-', linewidth=0.8, alpha=0.5, label='Phantom Divide' if 'Phantom Divide' not in [l.get_label() for l in ax.get_lines()] else "")
            
            if show_phantom_phase and 'w_eff' in res:
                w_eff = np.array(res['w_eff'])
                # Ensure masking works even if interpolation was slightly off
                mask_len = min(len(x_data), len(w_eff))
                ax.fill_between(x_data[:mask_len], w_eff[:mask_len], -1, 
                                where=w_eff[:mask_len] < -1, 
                                color='red', alpha=0.1)

    # --- Axes Formatting ---
    if xlim: 
        ax1.set_xlim(xlim)
        ax2.set_xlim(xlim)
    
    if ylim: 
        ax1.set_ylim(ylim)
    elif plotting_w:
        # Default for w plots
        ax1.set_ylim(-1.5, 1.2)
    
    ax1.set_xlabel(xlabel)
    ax2.set_xlabel(xlabel)
    
    # Smart Y-Label
    if plotting_w and len(quantities) == 2:
         ax1.set_ylabel("Equation of State (w)")
    elif normalize_non_w and not plotting_w:
         ax1.set_ylabel("Normalized Value ($X/X_0$)")
    else:
         ax1.set_ylabel("Value")

    if not use_redshift: 
        ax1.set_xscale('log')
        ax2.set_xscale('log')
    
    ax1.grid(True, which='both', linestyle='--', linewidth=0.5)
    ax2.grid(True, which='both', linestyle='--', linewidth=0.5)

    # --- Legend ---
    handles, labels = ax1.get_legend_handles_labels()
    
    # Remove duplicate labels if any
    by_label = dict(zip(labels, handles))
    
    # Add Initial Conditions box
    if show_initial_parameters:
        ic = results_hds.get('initial_conditions', {})
        if ic:
            # Attempt to get global alpha if not in ic
            alpha_val = ic.get('alpha', globals().get('global_alpha', '?'))
            
            ic_text = (
                f"Init Conds:\n"
                fr"$a_i = {ic.get('a_ini', 0):.1e}$" + "\n" +
                fr"$\phi_i = {ic.get('phi_i', 0):.2g}$" + "\n" +
                fr"$\alpha={alpha_val}$"
            )
            extra = Rectangle((0, 0), 1, 1, fc="w", fill=False, edgecolor='none', linewidth=0)
            by_label[ic_text] = extra

    ax1.legend(by_label.values(), by_label.keys(), loc='best', fontsize=9, framealpha=0.9)

    plt.suptitle(f'Comparison: {", ".join(quantities)}', fontsize=16)
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])

compare_eos(xlim=[0, 10])
#plot_relative_error(results_camb_dict, results_HDS, quantities_to_compare=['w_eff', 'w_phi', 'phi', 'phi_prime'])
#compare_results(results_camb_dict, results_HDS, quantities=['phi', 'phi_prime'], normalize_non_w=True)
plt.show()
compare_all_compatible_results(results_camb_dict, results_HDS)
