import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import interp1d
from scipy.integrate import odeint # Explicitly import odeint
import logging
from typing import List, Dict, Any, Tuple, Optional

# Set up logging for better feedback
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

# --- Fixed cosmological parameters from Planck 2018 ---
# --- Using CAMB units ---
c_in_km_s = 299_792.458
h = 0.6756
H0 = 100*h/c_in_km_s
rho_cr = 3*H0**2
omega_c = 0.12/h**2
omega_b = 0.022/h**2
omega_phot = 2.47e-5/h**2
omega_massless_nu = 3*(7/8)*(4/11)**(4/3)*omega_phot
omega_r = omega_phot + omega_massless_nu
omega_de = 1 - omega_c - omega_b - omega_r

# --- Helper Functions (moved to top for explicit definition order) ---

def find_critical_point(scale_factor_arr: np.ndarray, phi_prime_arr: np.ndarray) -> float:
    """
    Calculates the critical point for the scalar field derivative where it changes sign.
    Returns 0.0 if no such crossing is found.
    """
    idx = np.where(np.diff(np.sign(phi_prime_arr)))[0]
    if len(idx) > 0:
        c = idx[0]
        a_c = (scale_factor_arr[c] + scale_factor_arr[c+1]) / 2
        return a_c
    return 0.0

def find_all_phantom_crossings(a: np.ndarray, w_eff: np.ndarray) -> List[Tuple[float, float]]:
    """
    Detects all instances where w_eff crosses the -1 line (phantom crossings).
    Returns a list of (crossing_a, crossing_z) tuples.
    """
    crossings = []
    # Look for a sign change from w_eff > -1 to w_eff < -1 OR w_eff < -1 to w_eff > -1
    # We need to ensure w_eff is defined and not NaN
    valid_indices = np.where(~np.isnan(w_eff))
    a_valid = a[valid_indices]
    w_eff_valid = w_eff[valid_indices]

    for i in range(1, len(w_eff_valid)):
        # Check for crossing -1 in either direction
        if (w_eff_valid[i-1] > -1 and w_eff_valid[i] < -1) or \
           (w_eff_valid[i-1] < -1 and w_eff_valid[i] > -1):
            a1, a2 = a_valid[i-1], a_valid[i]
            w1, w2 = w_eff_valid[i-1], w_eff_valid[i]

            if (w2 - w1) != 0: # Avoid division by zero if w_eff is flat
                crossing_a = a1 + (-1 - w1) * (a2 - a1) / (w2 - w1)
                crossing_z = (1 / crossing_a) - 1
                crossings.append((crossing_a, crossing_z))
    return crossings

# --- Core Equations of the Cosmological Model ---

def H_curly(y: List[float], a: float, V0: float, rho_dm: float) -> float:
    """Calculates the conformal Hubble parameter H*a for the given state."""
    # y = [phi, phi_prime]
    _, phi_prime = y
    rho_phi = phi_prime**2 / (2 * a**2) + V0
    rho = rho_cr * (omega_r * a**(-4) + omega_b * a**(-3)) + rho_dm + rho_phi
    return a * np.sqrt(rho / 3)

def equations(y: List[float], a: float, V0: float, rho_dm_i: float, a_i: float, phi_i: float) -> List[float]:
    """
    Defines the system of differential equations for the scalar field (phi, phi_prime).
    Includes coupling of dark matter density to the scalar field.
    """
    phi, phi_prime = y
    # Dark matter density coupled to the scalar field
    rho_dm = rho_dm_i * (phi / phi_i) * (a_i / a)**3
    H = H_curly(y, a, V0, rho_dm)
    
    # Add a small epsilon to H and phi to prevent division by zero
    epsilon_denom = 1e-30
    H_safe = H if np.abs(H) > epsilon_denom else epsilon_denom
    phi_safe = phi if np.abs(phi) > epsilon_denom else epsilon_denom

    dphi = phi_prime / (a * H_safe)
    dphi_prime = -2 * phi_prime / a - a * rho_dm / (phi_safe * H_safe) # Use phi_safe and H_safe
    return np.array([dphi, dphi_prime])

def equations_loga(y: List[float], loga: float, V0: float, rho_dm_i: float, a_i: float, phi_i: float) -> List[float]:
    """
    Defines the system of differential equations with respect to log(a).
    Used for integration at very early times.
    """
    a = np.exp(loga)
    derivs = equations(y, a, V0, rho_dm_i, a_i, phi_i)
    return a * derivs

def integrate_cosmo(ic: List[float], a_ini: float, a_end: float, n_steps: int, V0: float, rho_dm_i: float) -> Tuple[np.ndarray, np.ndarray]:
    """
    Integrates the cosmological equations using a hybrid model:
    log-integration for early universe and normal integration for later times.
    """
    frac = 0.4  # Fraction of time-steps spent in log integration
    a_threshold = 1e-3  # Scale factor to switch integration methods
    phi_i = ic[0]

    logging.debug(f"integrate_cosmo called with ic={ic}, a_ini={a_ini}, a_end={a_end}") # Debug print

    n_steps_log = int(frac * n_steps)
    # Ensure a_log has at least 2 points for logspace
    if n_steps_log < 2:
        n_steps_log = 2
    a_log = np.logspace(np.log10(a_ini), np.log10(a_threshold), n_steps_log)
    loga = np.log(a_log)
    result_log = odeint(equations_loga, ic, loga, args=(V0, rho_dm_i, a_ini, phi_i))

    ic_normal_integration = result_log[-1]  # Initial conditions for normal integration
    n_steps_normal = n_steps - n_steps_log
    # Ensure a_normal has at least 2 points for linspace
    if n_steps_normal < 2:
        n_steps_normal = 2
    a_normal = np.linspace(a_threshold, a_end, n_steps_normal)
    result_normal = odeint(equations, ic_normal_integration, a_normal, args=(V0, rho_dm_i, a_ini, phi_i))

    return np.concatenate((a_log, a_normal)), np.concatenate((result_log, result_normal))

def find_fracs_de_dm_0(result: np.ndarray, V0: float, rho_dm_0: float) -> Tuple[float, float]:
    """Calculates the dark energy and dark matter fractions at a=1 (present day)."""
    _, phi_prime = result.T
    rho_phi_0 = phi_prime[-1]**2 / 2 + V0

    # Total density at a=1 (rho_r and rho_b are at a=1, so a**(-4) and a**(-3) become 1)
    rho_tot_0 = rho_cr * (omega_r + omega_b) + rho_dm_0 + rho_phi_0

    return rho_phi_0 / rho_tot_0, rho_dm_0 / rho_tot_0

def solve_system(
    ic_phi: float,
    ic_phi_prime: float,
    a_ini: float,
    a_end: float,
    n_steps: int,
    V0_guess_1: float,
    V0_guess_2: float
) -> Tuple[np.ndarray, np.ndarray, float, float]:
    """
    Solves the cosmological system using a shooting method to find V0 that matches
    the present-day dark energy density (omega_de).
    """
    logging.info("-----")
    phi_i = ic_phi
    logging.info(f"Begin shooting for phi_i = {phi_i}, phi_prime_i = {ic_phi_prime}")
    logging.info(f"Target omega_de: {omega_de:.6f}; Target omega_c = {omega_c:.6f}")

    # Initial conditions for odeint
    ic = [ic_phi, ic_phi_prime]

    # Initial guesses for shooting parameters 
    V0_1 = V0_guess_1
    V0_2 = V0_guess_2

    # Initial guess for rho_dm_i assumes no (phi/phi_i) factor
    rho_dm_i_guess = rho_cr * omega_c * a_ini**(-3)
    rho_dm_i = rho_dm_i_guess

    # Integrate KG with initial guesses
    a, result_1 = integrate_cosmo(ic, a_ini, a_end, n_steps, V0_1, rho_dm_i)
    _, result_2 = integrate_cosmo(ic, a_ini, a_end, n_steps, V0_2, rho_dm_i)

    # Correct missing phi/phi_i factor for rho_dm_i (based on current phi_0)
    # This recalculates rho_dm_i to ensure rho_dm(a=1) matches omega_c.
    phi_0_1 = result_1.T[0][-1]
    phi_0_2 = result_2.T[0][-1]
    # Update rho_dm_i based on the first guess's phi_0 for consistency in the loop
    rho_dm_i = rho_dm_i_guess * (phi_i / phi_0_1)

    # Evaluate omega_c and omega_de for initial guesses at a=1
    # rho_dm_0 is calculated at a=1, so (a_ini/a)**3 becomes (a_ini/1)**3
    rho_dm_0_1 = rho_dm_i_guess * (phi_0_1 / phi_i) * (a_ini)**3 # Use rho_dm_i_guess for a consistent initial calculation
    rho_dm_0_2 = rho_dm_i_guess * (phi_0_2 / phi_i) * (a_ini)**3

    omega_de_1, omega_c_1 = find_fracs_de_dm_0(result_1, V0_1, rho_dm_0_1)
    omega_de_2, omega_c_2 = find_fracs_de_dm_0(result_2, V0_2, rho_dm_0_2)

    # Assess errors at initial guesses
    error_dm_1 = (omega_c_1 - omega_c) / omega_c
    error_dm_2 = (omega_c_2 - omega_c) / omega_c
    error_de_1 = (omega_de_1 - omega_de) / omega_de
    error_de_2 = (omega_de_2 - omega_de) / omega_de

    logging.info(f"V0 = {V0_1:.6f} => omega_de = {omega_de_1:.6f} (error = {error_de_1:.6f}); omega_c = {omega_c_1:.6f} (error = {error_dm_1:.6f})")
    logging.info(f"V0 = {V0_2:.6f} => omega_de = {omega_de_2:.6f} (error = {error_de_2:.6f}); omega_c = {omega_c_2:.6f} (error = {error_dm_2:.6f})")

    # Check if initial guesses encapsulate the solution for omega_de
    encapsulating = (omega_de_1 - omega_de) * (omega_de_2 - omega_de) < 0
    if not encapsulating:
        logging.warning("WARNING: initial guesses for V0 did not encapsulate the target omega_de")
        logging.warning(f"Target omega_de: {omega_de}")
        logging.warning(f"V0 = {V0_1:.6f} => omega_de = {omega_de_1:.6f}")
        logging.warning(f"V0 = {V0_2:.6f} => omega_de = {omega_de_2:.6f}")

    iters = 0
    max_iters = 20
    # Secant method iteration
    while (iters < max_iters):
        iters += 1

        # Fit a line between (V0_1, omega_de_1) and (V0_2, omega_de_2)
        # Handle cases where V0_2 - V0_1 is zero or very small to prevent division by zero
        if abs(V0_2 - V0_1) < 1e-10: # A small epsilon to check for near-zero difference
            logging.warning("V0_2 and V0_1 are too close. Adjusting V0_2 slightly for secant method.")
            V0_2 += 1e-6 # Slightly perturb V0_2 to continue
            # Recalculate omega_de_2
            _, result_2_recalc = integrate_cosmo(ic, a_ini, a_end, n_steps, V0_2, rho_dm_i)
            phi_0_2_recalc = result_2_recalc.T[0][-1]
            rho_dm_0_2_recalc = rho_dm_i_guess * (phi_0_2_recalc / phi_i) * (a_ini)**3
            omega_de_2, _ = find_fracs_de_dm_0(result_2_recalc, V0_2, rho_dm_0_2_recalc)

        a_line = (omega_de_2 - omega_de_1) / (V0_2 - V0_1)
        b_line = omega_de_2 - a_line * V0_2

        # Choose the point where the line would cross the target omega_de
        # Handle cases where a_line is zero or very small
        if abs(a_line) < 1e-10:
            logging.warning("a_line is too close to zero. Secant method struggling. Breaking loop.")
            break # Exit if secant method can't make progress

        V0_try = (omega_de - b_line) / a_line

        # Integrate KG assuming this new V0
        _, result_try = integrate_cosmo(ic, a_ini, a_end, n_steps, V0_try, rho_dm_i)
        phi_0_try = result_try.T[0][-1]

        # Evaluate omega_de and omega_c for new point
        rho_dm_0_try = rho_dm_i_guess * (phi_0_try / phi_i) * (a_ini)**3 # Always use rho_dm_i_guess here
        omega_de_try, omega_c_try = find_fracs_de_dm_0(result_try, V0_try, rho_dm_0_try)

        # Assess errors at new point
        error = (omega_de_try - omega_de) / omega_de
        error_omega_c = (omega_c_try - omega_c) / omega_c
        logging.info(f"V0 = {V0_try:.6f} => omega_de = {omega_de_try:.6f} (error = {error:.6f}); omega_c = {omega_c_try:.6f} (error = {error_omega_c:.6f})")

        # Update rho_dm_i for next iteration based on the new phi_0
        rho_dm_i = rho_dm_i_guess * (phi_i / result_try.T[0][-1])

        # Exit condition
        if abs(error) < 1e-4:
            break

        # Substitute one of the initial V0 guesses by the new V0 guess
        # This maintains the bracketing if it was initially present,
        # or updates the points for secant method otherwise.
        if (omega_de_try > omega_de):
            V0_1 = V0_try
            omega_de_1 = omega_de_try
        else:
            V0_2 = V0_try
            omega_de_2 = omega_de_try

    if abs(error) > 1e-4: # Check if the loop exited due to max_iters
        logging.warning(f"WARNING: reached max iterations in shooting with error = {error}")
        raise RuntimeError(f"Shooting method failed to converge for phi_i={ic_phi}, phi_prime_i={ic_phi_prime}")
    else:
        logging.info(f"Finished shooting successfully after {iters} iterations")
    return a, result_try, V0_try, rho_dm_i

def calculate_derived_quantities(
    a: np.ndarray,
    result: np.ndarray,
    V0: float,
    rho_dm_i_for_case: float,
    a_ini: float,
    phi_initial_val_for_case: float
) -> Dict[str, np.ndarray]:
    """
    Calculates various derived quantities (densities, equations of state)
    from the integration results.
    """
    phi_a, phi_prime_a = result.T

    # Calculate densities for the current model
    rho_de_a = phi_prime_a**2 / (2 * a**2) + V0
    rho_dm_a = rho_dm_i_for_case * (phi_a / phi_initial_val_for_case) * (a_ini / a)**3
    rho_r_a = rho_cr * omega_r * a**(-4)
    rho_b_a = rho_cr * omega_b * a**(-3)

    rho_tot_a = rho_r_a + rho_b_a + rho_dm_a + rho_de_a

    # Calculate equation of state for dark energy
    # Add a small epsilon to rho_de_a to prevent division by zero
    epsilon_denom = 1e-40
    rho_de_a_safe = np.where(np.abs(rho_de_a) < epsilon_denom, epsilon_denom, rho_de_a)
    w_de_a = (phi_prime_a**2 / (2 * a**2) - V0) / rho_de_a_safe

    # Calculate H_curly (dimensionless Hubble parameter) for each a
    # We need to calculate it using the values of phi_a and phi_prime_a at each step
    H_curly_a = np.array([H_curly([phi_a[i], phi_prime_a[i]], a[i], V0, rho_dm_a[i]) for i in range(len(a))])

    # Calculate effective equation of state using the provided expression
    # w_eff = w_phi + (phi_prime / (3 * H_curly * phi)) * (rho_chi / rho_phi)
    # Add a small epsilon to denominators to prevent division by zero for numerical stability
    phi_a_safe = np.where(np.abs(phi_a) < epsilon_denom, epsilon_denom, phi_a)
    H_curly_a_safe = np.where(np.abs(H_curly_a) < epsilon_denom, epsilon_denom, H_curly_a)
    
    # This is the coupling term for w_eff
    coupling_term_a = (phi_prime_a / (3 * H_curly_a_safe * phi_a_safe)) * (rho_dm_a / rho_de_a_safe)
    w_eff_a = w_de_a + coupling_term_a

    # Calculate new quantity: phi_prime / (H * phi)
    phi_prime_over_H_phi = phi_prime_a / (H_curly_a_safe * phi_a_safe)


    return {
        'phi_a': phi_a,
        'phi_prime_a': phi_prime_a,
        'rho_de_a': rho_de_a,
        'rho_dm_a': rho_dm_a,
        'w_de_a': w_de_a,
        'rho_tot_a': rho_tot_a,
        'w_eff_a': w_eff_a,
        'rho_r_a': rho_r_a,
        'rho_b_a': rho_b_a,
        'H_curly_a': H_curly_a,
        'w_eff_coupling_term_a': coupling_term_a, 
        'phi_prime_over_H_phi': phi_prime_over_H_phi 
    }
    
def get_phantom_phase_data(
    sweep_param_name: str,
    sweep_values_phi: Optional[np.ndarray] = None,
    sweep_values_phi_prime: Optional[np.ndarray] = None,
    fixed_phi_i: float = 10,
    fixed_phi_prime_i: float = 4.5e6,
    a_ini: float = 1e-7,
    a_end: float = 1,
    n_steps: int = 10_000,
    V0_guess_1: float = 1.15 * rho_cr * omega_de,
    V0_guess_2: float = 0.9 * rho_cr * omega_de,
    ax: Optional[plt.Axes] = None
) -> None:
    """
    Sweeps through initial conditions and plots the min/max of the effective
    equation of state w_eff on a specified axes object.
    
    Args:
        sweep_param_name: The name of the parameter to sweep ('phi_i', 'phi_prime_i', or 'both').
        sweep_values_phi: A numpy array of phi_i values to sweep over.
        sweep_values_phi_prime: A numpy array of phi_prime_i values to sweep over.
        fixed_phi_i: The fixed initial value of phi, used when sweeping phi_prime_i.
        fixed_phi_prime_i: The fixed initial value of phi_prime, used when sweeping phi_i.
        a_ini, a_end, n_steps: Cosmological simulation parameters.
        V0_guess_1, V0_guess_2: Initial guesses for the shooting method.
        ax: The matplotlib axes object to plot on.
    """
    if sweep_param_name not in ['phi_i', 'phi_prime_i', 'both']:
        raise ValueError("sweep_param_name must be 'phi_i', 'phi_prime_i', or 'both'")

    if sweep_param_name == 'both':
        if sweep_values_phi is None or sweep_values_phi_prime is None:
            raise ValueError("For 'both' sweep, sweep_values_phi and sweep_values_phi_prime must be provided.")
        if ax is None:
            raise ValueError("An axes object must be provided for the 'both' sweep.")
        
        min_w_eff_matrix = np.full((len(sweep_values_phi_prime), len(sweep_values_phi)), np.nan)
        
        logging.info("Starting a 2D sweep for contour plot...")
        for i, phi_prime_val in enumerate(sweep_values_phi_prime):
            for j, phi_val in enumerate(sweep_values_phi):
                logging.info(f"Solving for phi_i = {phi_val:.2f}, phi_prime_i = {phi_prime_val:.2e}")
                try:
                    a, result, V0, rho_dm_i = solve_system(
                        ic_phi=phi_val,
                        ic_phi_prime=phi_prime_val,
                        a_ini=a_ini,
                        a_end=a_end,
                        n_steps=n_steps,
                        V0_guess_1=V0_guess_1,
                        V0_guess_2=V0_guess_2
                    )
                    derived_quantities = calculate_derived_quantities(
                        a, result, V0, rho_dm_i, a_ini, phi_val
                    )
                    w_eff_a = derived_quantities['w_eff_a']
                    w_eff_a_filtered = w_eff_a[~np.isnan(w_eff_a)]
                    if w_eff_a_filtered.size > 0:
                        min_w_eff_matrix[i, j] = np.min(w_eff_a_filtered)
                except RuntimeError as e:
                    logging.error(f"Failed to solve for phi_i = {phi_val}, phi_prime_i = {phi_prime_val}. Skipping.")

        X, Y = np.meshgrid(sweep_values_phi, sweep_values_phi_prime)
        contour = ax.contourf(X, Y, min_w_eff_matrix, levels=20, cmap='viridis')
        cbar = plt.colorbar(contour, ax=ax)
        cbar.set_label(r'Minimum $w_{eff}$')
        
        ax.set_title(r'Contour Plot of Min $w_{eff}$')
        ax.set_xlabel(r'Initial Scalar Field Amplitude $\phi_i$')
        ax.set_ylabel(r"Initial Scalar Field Derivative $\phi'_i$")
        ax.grid(True)
        ax.set_yscale('log')

    else:
        min_w_effs = []
        max_w_effs = []
        
        sweep_values = sweep_values_phi if sweep_param_name == 'phi_i' else sweep_values_phi_prime
        
        for val in sweep_values:
            if sweep_param_name == 'phi_i':
                ic_phi = val
                ic_phi_prime = fixed_phi_prime_i
            else: # phi_prime_i
                ic_phi = fixed_phi_i
                ic_phi_prime = val
                
            logging.info(f"Sweeping {sweep_param_name} = {val:.4e}")
            
            try:
                a, result, V0, rho_dm_i = solve_system(
                    ic_phi=ic_phi,
                    ic_phi_prime=ic_phi_prime,
                    a_ini=a_ini,
                    a_end=a_end,
                    n_steps=n_steps,
                    V0_guess_1=V0_guess_1,
                    V0_guess_2=V0_guess_2
                )
                
                derived_quantities = calculate_derived_quantities(
                    a, result, V0, rho_dm_i, a_ini, ic_phi
                )
                
                w_eff_a = derived_quantities['w_eff_a']
                w_eff_a_filtered = w_eff_a[~np.isnan(w_eff_a)]
                
                min_w_effs.append(np.min(w_eff_a_filtered) if w_eff_a_filtered.size > 0 else np.nan)
                max_w_effs.append(np.max(w_eff_a_filtered) if w_eff_a_filtered.size > 0 else np.nan)
                
            except RuntimeError as e:
                logging.error(f"Failed to solve for {sweep_param_name} = {val:.4e}. Skipping.")
                min_w_effs.append(np.nan)
                max_w_effs.append(np.nan)

        if ax is None:
            raise ValueError("An axes object must be provided for single-parameter sweeps.")
            
        if sweep_param_name == 'phi_i':
            ax.plot(sweep_values, min_w_effs, 'o--', label=r'Min $w_{eff}$ ($\phi_i$ sweep)', color='blue')
            ax.plot(sweep_values, max_w_effs, 'o-', label=r'Max $w_{eff}$ ($\phi_i$ sweep)', color='red')
            ax.set_xlabel(r'$\phi_{i}$ [CAMB units]')
            ax.set_title(r"Effective EoS, $w_{eff}$, vs. $\phi_{i}$" + f"(for fixed $\phi'_i = {fixed_phi_prime_i}$)")
        else: # phi_prime_i sweep
            ax.plot(sweep_values, min_w_effs, 's--', label=r"Min $w_{eff}$ ($\phi'_i$ sweep)", color='cyan')
            ax.plot(sweep_values, max_w_effs, 's-', label=r"Max $w_{eff}$ ($\phi'_i$ sweep)", color='magenta')
            ax.set_xlabel(r"$\phi'_{i}$ [CAMB units]")
            ax.set_title(r"Effective EoS, $w_{eff}$, vs. $\phi'_{i}$" + f"(for fixed $\phi_i = {fixed_phi_i}$)")

        ax.legend(loc='center right')
        ax.set_ylabel(r'$w_{eff}$')
        ax.grid(True)
        if sweep_param_name == 'phi_prime_i':
            ax.set_xscale('log')

def get_phantom_redshift_data(
    sweep_param_name: str,
    sweep_values_phi: Optional[np.ndarray] = None,
    sweep_values_phi_prime: Optional[np.ndarray] = None,
    fixed_phi_i: float = 10,
    fixed_phi_prime_i: float = 4.5e6,
    a_ini: float = 1e-7,
    a_end: float = 1,
    n_steps: int = 10_000,
    V0_guess_1: float = 1.15 * rho_cr * omega_de,
    V0_guess_2: float = 0.9 * rho_cr * omega_de,
    ax: Optional[plt.Axes] = None
) -> None:
    """
    Sweeps through initial conditions and plots the redshift where w_eff becomes phantom
    (w_eff < -1).
    
    Args:
        sweep_param_name: The name of the parameter to sweep ('phi_i', 'phi_prime_i', or 'both').
        sweep_values_phi: A numpy array of phi_i values to sweep over.
        sweep_values_phi_prime: A numpy array of phi_prime_i values to sweep over.
        fixed_phi_i: The fixed initial value of phi, used when sweeping phi_prime_i.
        fixed_phi_prime_i: The fixed initial value of phi_prime, used when sweeping phi_i.
        a_ini, a_end, n_steps: Cosmological simulation parameters.
        V0_guess_1, V0_guess_2: Initial guesses for the shooting method.
        ax: The matplotlib axes object to plot on.
    """
    if sweep_param_name not in ['phi_i', 'phi_prime_i', 'both']:
        raise ValueError("sweep_param_name must be 'phi_i', 'phi_prime_i', or 'both'")
    
    if ax is None:
        raise ValueError("An axes object must be provided for plotting.")

    def find_phantom_redshift(w_eff, a):
        """
        Finds the first redshift where w_eff drops below -1.
        
        Returns:
            The redshift z, or np.nan if the phantom phase is not reached.
        """
        w_eff_filtered = w_eff[~np.isnan(w_eff)]
        a_filtered = a[~np.isnan(w_eff)]
        
        # Find the first index where w_eff < -1
        phantom_indices = np.where(w_eff_filtered < -1)[0]
        
        if phantom_indices.size > 0:
            first_phantom_index = phantom_indices[0]
            # Get the scale factor at this point
            a_phantom = a_filtered[first_phantom_index]
            z_phantom = (1 / a_phantom) - 1
            return z_phantom
        else:
            return np.nan

    if sweep_param_name == 'both':
        if sweep_values_phi is None or sweep_values_phi_prime is None:
            raise ValueError("For 'both' sweep, sweep_values_phi and sweep_values_phi_prime must be provided.")
        
        z_phantom_matrix = np.full((len(sweep_values_phi_prime), len(sweep_values_phi)), np.nan)
        
        logging.info("Starting a 2D sweep for contour plot of redshift...")
        for i, phi_prime_val in enumerate(sweep_values_phi_prime):
            for j, phi_val in enumerate(sweep_values_phi):
                logging.info(f"Solving for phi_i = {phi_val:.2f}, phi_prime_i = {phi_prime_val:.2e}")
                try:
                    a, result, V0, rho_dm_i = solve_system(
                        ic_phi=phi_val,
                        ic_phi_prime=phi_prime_val,
                        a_ini=a_ini,
                        a_end=a_end,
                        n_steps=n_steps,
                        V0_guess_1=V0_guess_1,
                        V0_guess_2=V0_guess_2
                    )
                    derived_quantities = calculate_derived_quantities(
                        a, result, V0, rho_dm_i, a_ini, phi_val
                    )
                    z_phantom = find_phantom_redshift(derived_quantities['w_eff_a'], a)
                    z_phantom_matrix[i, j] = z_phantom
                except RuntimeError as e:
                    logging.error(f"Failed to solve for phi_i = {phi_val}, phi_prime_i = {phi_prime_val}. Skipping.")

        X, Y = np.meshgrid(sweep_values_phi, sweep_values_phi_prime)
        contour = ax.contourf(X, Y, z_phantom_matrix, levels=20, cmap='inferno')
        cbar = plt.colorbar(contour, ax=ax)
        cbar.set_label(r'Redshift $z_{phantom}$')
        
        ax.set_title(r'Contour Plot of $z_{phantom}$')
        ax.set_xlabel(r'Initial Scalar Field Amplitude $\phi_i$')
        ax.set_ylabel(r"Initial Scalar Field Derivative $\phi'_i$")
        ax.grid(True)
        ax.set_yscale('log')

    else:
        z_phantoms = []
        
        sweep_values = sweep_values_phi if sweep_param_name == 'phi_i' else sweep_values_phi_prime
        
        for val in sweep_values:
            if sweep_param_name == 'phi_i':
                ic_phi = val
                ic_phi_prime = fixed_phi_prime_i
            else: # phi_prime_i
                ic_phi = fixed_phi_i
                ic_phi_prime = val
                
            logging.info(f"Sweeping {sweep_param_name} = {val:.4e}")
            
            try:
                a, result, V0, rho_dm_i = solve_system(
                    ic_phi=ic_phi,
                    ic_phi_prime=ic_phi_prime,
                    a_ini=a_ini,
                    a_end=a_end,
                    n_steps=n_steps,
                    V0_guess_1=V0_guess_1,
                    V0_guess_2=V0_guess_2
                )
                
                derived_quantities = calculate_derived_quantities(
                    a, result, V0, rho_dm_i, a_ini, ic_phi
                )
                
                z_phantom = find_phantom_redshift(derived_quantities['w_eff_a'], a)
                z_phantoms.append(z_phantom)
                
            except RuntimeError as e:
                logging.error(f"Failed to solve for {sweep_param_name} = {val:.4e}. Skipping.")
                z_phantoms.append(np.nan)

        if sweep_param_name == 'phi_i':
            ax.plot(sweep_values, z_phantoms, 'o-', label=r'$z_{phantom}$ ($\phi_i$ sweep)', color='purple')
            ax.set_xlabel(r'$\phi_{i}$ [CAMB units]')
            ax.set_title(r"Redshift when $w_{eff} < -1$ vs. $\phi_{i}$" + f"(for fixed $\phi'_i = {fixed_phi_prime_i}$)")
        else: # phi_prime_i sweep
            ax.plot(sweep_values, z_phantoms, 's-', label=r"$z_{phantom}$ ($\phi'_i$ sweep)", color='green')
            ax.set_xlabel(r"$\phi'_{i}$ [CAMB units]")
            ax.set_title(r"Redshift when $w_{eff} < -1$ vs. $\phi'_{i}$" + f"(for fixed $\phi_i = {fixed_phi_i}$)")

        ax.legend(loc='upper right')
        ax.set_ylabel(r'Redshift $z_{phantom}$')
        ax.grid(True)
        if sweep_param_name == 'phi_prime_i':
            ax.set_xscale('log')

def extract_data_at_phantom_crossing(a: np.ndarray, derived_quantities: Dict[str, np.ndarray]) -> Optional[Dict[str, float]]:
    """
    Finds the first phantom crossing point and returns the value of key quantities at that point.
    Returns None if no crossing is found.
    """
    w_eff = derived_quantities['w_eff_a']
    
    crossings = find_all_phantom_crossings(a, w_eff)
    if not crossings:
        return None
    
    crossing_a, _ = crossings[0]
    
    # Use interpolation to find values at the crossing scale factor
    interp_rho_dm_rho_de = interp1d(a, derived_quantities['rho_dm_a'] / derived_quantities['rho_de_a'], bounds_error=False, fill_value=np.nan)
    interp_coupling_term = interp1d(a, derived_quantities['w_eff_coupling_term_a'], bounds_error=False, fill_value=np.nan)
    
    # Calculate Q = -rho_dm / phi
    rho_dm = derived_quantities['rho_dm_a']
    phi = derived_quantities['phi_a']
    Q = -rho_dm / phi
    interp_Q = interp1d(a, Q, bounds_error=False, fill_value=np.nan)
    
    return {
        'a': crossing_a,
        'rho_dm/rho_de': interp_rho_dm_rho_de(crossing_a).item(),
        'coupling_term': interp_coupling_term(crossing_a).item(),
        'Q': interp_Q(crossing_a).item(),
    }

def main():
    """Main function to execute the cosmological simulations and plotting."""

    # --- Simulation parameters ---
    a_ini = 1e-7
    a_end = 1
    n_steps = 10_000

    #=========================================================
    # Initial conditions
    #=========================================================

    phi_i_main = 10 
    phi_prime_i_main = 4.5e6 
    
    # Create a single figure with three subplots
    fig1, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6)) # Adjust figsize as needed
    fig1.suptitle('Phantom Phase Analysis for Coupled Dark Energy', fontsize=16)

    # Sweep over phi_i on the first subplot
    phi_i_sweep_values = np.linspace(1, 25, 40)
    get_phantom_phase_data(
        sweep_param_name='phi_i',
        sweep_values_phi=phi_i_sweep_values,
        fixed_phi_prime_i=phi_prime_i_main,
        a_ini=a_ini,
        a_end=a_end,
        n_steps=n_steps,
        V0_guess_1=1.15 * rho_cr * omega_de,
        V0_guess_2=0.9 * rho_cr * omega_de,
        ax=ax1 # Pass the first axes
    )

    # Sweep over phi_prime_i on the second subplot
    phi_prime_i_sweep_values = np.logspace(np.log10(1e4), np.log10(8e6), 40)
    get_phantom_phase_data(
        sweep_param_name='phi_prime_i',
        sweep_values_phi_prime=phi_prime_i_sweep_values,
        fixed_phi_i=phi_i_main,
        a_ini=a_ini,
        a_end=a_end,
        n_steps=n_steps,
        V0_guess_1=1.15 * rho_cr * omega_de,
        V0_guess_2=0.9 * rho_cr * omega_de,
        ax=ax2 # Pass the second axes
    )
    
    # Run the 2D sweep and create the contour plot on the third subplot
    get_phantom_phase_data(
        sweep_param_name='both',
        sweep_values_phi=np.linspace(2, 25, 10),
        sweep_values_phi_prime=np.logspace(np.log10(1e4), np.log10(8e6), 10),
        a_ini=a_ini,
        a_end=a_end,
        n_steps=n_steps,
        V0_guess_1=1.15 * rho_cr * omega_de,
        V0_guess_2=0.9 * rho_cr * omega_de,
        ax=ax3 # Pass the third axes
    )
    
    plt.tight_layout(rect=[0, 0.03, 1, 0.95]) # Adjust layout to make room for suptitle

    #=========================================================
    # Phantom redshift analysis
    #=========================================================

    fig2, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6)) # Adjust figsize as needed
    fig2.suptitle('Phantom Redshift Analysis for Coupled Dark Energy', fontsize=16)

    # Sweep over phi_i on the first subplot
    get_phantom_redshift_data(
        sweep_param_name='phi_i',
        sweep_values_phi=phi_i_sweep_values,
        fixed_phi_prime_i=phi_prime_i_main,
        a_ini=a_ini,
        a_end=a_end,
        n_steps=n_steps,
        V0_guess_1=1.15 * rho_cr * omega_de,
        V0_guess_2=0.9 * rho_cr * omega_de,
        ax=ax1 # Pass the first axes
    )

    # Sweep over phi_prime_i on the second subplot
    get_phantom_redshift_data(
        sweep_param_name='phi_prime_i',
        sweep_values_phi_prime=phi_prime_i_sweep_values,
        fixed_phi_i=phi_i_main,
        a_ini=a_ini,
        a_end=a_end,
        n_steps=n_steps,
        V0_guess_1=1.15 * rho_cr * omega_de,
        V0_guess_2=0.9 * rho_cr * omega_de,
        ax=ax2 # Pass the second axes
    )
    
    # Run the 2D sweep and create the contour plot on the third subplot
    get_phantom_redshift_data(
        sweep_param_name='both',
        sweep_values_phi=np.linspace(5, 25, 10),
        sweep_values_phi_prime=np.logspace(np.log10(1e6), np.log10(8e6), 10),
        a_ini=a_ini,
        a_end=a_end,
        n_steps=n_steps,
        V0_guess_1=1.15 * rho_cr * omega_de,
        V0_guess_2=0.9 * rho_cr * omega_de,
        ax=ax3 # Pass the third axes
    )
    
    plt.tight_layout(rect=[0, 0.03, 1, 0.95]) # Adjust layout to make room for suptitle
    plt.show()

if __name__ == "__main__":
    main()
