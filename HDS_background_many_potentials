import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import numpy as np
import abc
from scipy.interpolate import interp1d
import logging
from typing import List, Dict, Any, Tuple, Optional, Type
from scipy.integrate import odeint, cumulative_trapezoid

# Set up logging for better feedback
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

# --- Fixed cosmological parameters from Planck 2018 ---
# --- Using CAMB units ---
c_in_km_s = 299_792.458
h = 0.6756
H0 = 100*h/c_in_km_s
rho_cr = 3*H0**2
omega_c = 0.12/h**2
omega_b = 0.022/h**2
omega_phot = 2.47e-5/h**2
omega_massless_nu = 3*(7/8)*(4/11)**(4/3)*omega_phot
omega_r = omega_phot + omega_massless_nu
omega_de = 1 - omega_c - omega_b - omega_r
omega_de_target = omega_de
omega_c_target = omega_c

global_alpha=1 # 0.2, 0.5 and 0.7 are interesting for Gaussian, probably look like K-essence

# =============================================================================
# Base abstract class for potentials
# =============================================================================

class ScalarPotential(abc.ABC):
    """
    An abstract base class that defines the interface for all potential models.

    Every potential implemented MUST inherit from this class and implement 
    its abstract methods.
    """
    def __init__(self, name: str):
        self.name = name
        # Each potential will store its unique parameters in this dictionary.
        self.params: Dict[str, Any] = {}

    @abc.abstractmethod
    def value(self, phi: float) -> float:
        """
        Calculates the value of the potential, V(phi), at a given phi.
        This method MUST be implemented by any child class.
        """
        pass

    @abc.abstractmethod
    def derivative(self, phi: float) -> float:
        """
        Calculates the derivative of the potential, dV/dphi, at a given phi.
        This method MUST be implemented by any child class.
        """
        pass

    def __repr__(self) -> str:
        """Provides a clean string representation of the potential object."""
        return f"{self.name} Potential with params: {self.params}"

# =============================================================================
# 2. Specific Potential Implementations
# =============================================================================

class ConstantPotential(ScalarPotential):
    """
    Constant potential, V(phi) = V0.
    """
    def __init__(self, V0: float):
        super().__init__("Constant")
        self.params['V0'] = V0

    def value(self, phi: float) -> float:
        """Returns the constant value V0, regardless of phi."""
        return self.params['V0']

    def derivative(self, phi: float) -> float:
        """The derivative of a constant is always zero."""
        return 0.0

class ExponentialPotential(ScalarPotential):
    """
    An exponential potential of the form V(phi) = A * exp(B * phi).
    """
    def __init__(self, A: float, B: float):
        super().__init__("Exponential")
        self.params['A'] = A
        self.params['B'] = B

    def value(self, phi: float) -> float:
        """Calculates V(phi) = A * exp(B * phi)."""
        A = self.params['A']
        B = self.params['B']
        return A * np.exp(B * phi)

    def derivative(self, phi: float) -> float:
        """Calculates dV/dphi = A * B * exp(B * phi)."""
        A = self.params['A']
        B = self.params['B']
        return A * B * np.exp(B * phi)
    
class PowerLawPotential(ScalarPotential):
    """
    A power law potential of the form V(phi) = A + B*\phi + C*\phi**2.
    """
    def __init__(self, A: float, B: float, C: float):
        super().__init__("Power Law")
        self.params['A'] = A
        self.params['B'] = B
        self.params['C'] = C

    def value(self, phi: float) -> float:
        """Calculates V(phi) = A + B*phi + C*phi**2."""
        A = self.params['A']
        B = self.params['B']
        C = self.params['C']
        return A + B*phi + C*phi**2

    def derivative(self, phi: float) -> float:
        """Calculates dV/dphi = B + 2 * C * phi."""
        B = self.params['B']
        C = self.params['C']
        return B + 2 * C * phi
    
class GaussianPotential(ScalarPotential):
    """
    A Gaussian potential of the form V(phi) = A*exp{-B*(x-C)**2}.
    """
    def __init__(self, A: float, B: float, C: float):
        super().__init__("Gaussian")
        self.params['A'] = A
        self.params['B'] = B
        self.params['C'] = C

    def value(self, phi: float) -> float:
        """Calculates V(phi) = V(phi) = A*exp{-B*(x-C)**2}."""
        A = self.params['A']
        B = self.params['B']
        C = self.params['C']
        return A*(np.exp(-B*(phi-C)**2))

    def derivative(self, phi: float) -> float:
        """Calculates dV/dphi = -2*B*(phi-C)*V(phi)."""
        A = self.params['A']
        B = self.params['B']
        C = self.params['C']
        return -2*B*(phi-C)*self.value(phi)

class InversePowerLawPotential(ScalarPotential):
    """
    An inverse power law potential of the form V(phi) = A * phi^(-B).
    """
    def __init__(self, A: float, B: float):
        super().__init__("Inverse Power Law")
        self.params['A'] = A
        self.params['B'] = B

    def value(self, phi: float) -> float:
        """Calculates V(phi) = A * phi^(-B)."""
        A = self.params['A']
        B = self.params['B']
        return np.where(phi != 0, A * phi**(-B), -np.inf)
    
    def derivative(self, phi: float) -> float:
        """Calculates dV/dphi = -A * B * phi^(-B-1)."""
        A = self.params['A']
        B = self.params['B']
        return np.where(phi != 0, -A * B * phi**(-B - 1), -np.inf)

# =============================================================================
# 3. Main functions for HDS solving
# =============================================================================

def H_curly(y: List[float], a: float, rho_dm: float, potential_object: ScalarPotential) -> float:
    """
    Calculates the conformal Hubble parameter H*a for the given state.
    """
    phi, phi_prime = y
   
    V_phi = potential_object.value(phi)
    
    rho_phi = phi_prime**2 / (2 * (a**2)) + V_phi
    rho = rho_cr * (omega_r * a**(-4) + omega_b * a**(-3)) + rho_dm + rho_phi

    return a * np.sqrt(rho / 3) if rho >= 0 else 0.0

def equations(y: List[float], a: float, rho_dm_i: float, a_i: float, phi_i: float, potential_object: ScalarPotential) -> np.ndarray:
    """
    Defines the Klein-Gordon equation for the DE field and the analytical expression for the CDM energy density.
    The integration variable is the scale factor 'a'.
    """
    
    alpha = global_alpha # I really have to see what is going on with this boy...

    phi, phi_prime = y
    rho_dm = rho_dm_i * ((phi / phi_i)**alpha) * (a_i / a)**3

    H = H_curly(y, a, rho_dm, potential_object)
    
    epsilon_denom = 1e-30
    H_safe = H if np.abs(H) > epsilon_denom else np.sign(H) * epsilon_denom if H != 0 else epsilon_denom
    phi_safe = phi if np.abs(phi) > epsilon_denom else np.sign(phi) * epsilon_denom if phi != 0 else epsilon_denom

    # Call the .derivative() method on the passed object to get dV/dphi
    dV_dphi_val = potential_object.derivative(phi)

    # Assumes y = [phi, phi'], where phi' is the derivative wrt conformal time (eta)
    dphi_da = phi_prime / (a * H_safe)
    dphi_prime_da = -2 * phi_prime / a - (a * dV_dphi_val / H_safe) - (a * rho_dm * alpha / (phi_safe * H_safe))
    
    return np.array([dphi_da, dphi_prime_da])

def equations_loga(y: List[float], loga: float, rho_dm_i: float, a_i: float, phi_i: float, potential_object: ScalarPotential) -> np.ndarray:
    """
    Defines the system of differential equations with respect to log(a).
    It also takes a potential_object and passes it to the core equations.
    """
    a = np.exp(loga)
    # The change of variables: dy/d(loga) = a * dy/da
    derivs_wrt_a = equations(y, a, rho_dm_i, a_i, phi_i, potential_object)
    return a * derivs_wrt_a

# =============================================================================
# 4. Shooting method to find initial conditions
#    It uses the secant method to shoot for the initial parameters of
#    the dark energy density and the Potential, in case it fails, it
#    switches to the bisection method an tries again.
#
#    This is not working properly yet and requires a review and
#    reimplementation. 
# =============================================================================

def integrate_cosmo(ic: List[float], a_ini: float, a_end: float, n_steps: int, rho_dm_i: float, potential_object: ScalarPotential) -> Tuple[np.ndarray, np.ndarray]:
    """Integrates the cosmological equations using a hybrid log/linear scale."""
    frac, a_threshold = 0.4, 1e-3
    phi_i = ic[0]
    n_steps_log = max(2, int(frac * n_steps))
    a_log = np.logspace(np.log10(a_ini), np.log10(a_threshold), n_steps_log)
    
    args_ode = (rho_dm_i, a_ini, phi_i, potential_object)
    result_log = odeint(equations_loga, ic, np.log(a_log), args=args_ode)

    ic_normal = result_log[-1]
    n_steps_normal = max(2, n_steps - n_steps_log)
    a_normal = np.linspace(a_threshold, a_end, n_steps_normal)
    result_normal = odeint(equations, ic_normal, a_normal, args=args_ode)

    # Remove the duplicate point at the threshold
    full_a = np.concatenate((a_log, a_normal[1:]))
    full_result = np.concatenate((result_log, result_normal[1:]))
    return full_a, full_result

def find_present_day_fractions(result: np.ndarray, a_ini: float, rho_dm_i: float, potential_object: ScalarPotential) -> Tuple[float, float]:
    """Calculates the dark energy and dark matter fractions at a=1."""
    phi_0, phi_prime_0 = result[-1]
    phi_i = result[0, 0]

    V_phi_0 = potential_object.value(phi_0)
    rho_phi_0 = phi_prime_0**2 / 2 + V_phi_0 # a = 1 today
    rho_dm_0 = rho_dm_i * (phi_0 / phi_i) * (a_ini)**3
    
    rho_tot_0 = rho_cr * (omega_r + omega_b) + rho_dm_0 + rho_phi_0
    
    if rho_tot_0 == 0: return 0.0, 0.0
    return rho_phi_0 / rho_tot_0, rho_dm_0 / rho_tot_0

def _shoot_for_rho_dm_i(ic: List[float], a_ini: float, a_end: float, n_steps: int, potential_object: ScalarPotential) -> float:
    """INNER LOOP: Finds rho_dm_i to match omega_c_target for a fixed potential."""
    phi_i = ic[0]
    rho_dm_i_guess_base = rho_cr * omega_c_target * a_ini**(-3)
    rho_dm_i_1 = rho_dm_i_guess_base * 0.95
    rho_dm_i_2 = rho_dm_i_guess_base * 1.05
    
    # --- Attempt 1: Secant Method ---
    converged = False
    for _ in range(20):
        _, result_1 = integrate_cosmo(ic, a_ini, a_end, n_steps, rho_dm_i_1, potential_object)
        _, omega_c_1 = find_present_day_fractions(result_1, a_ini, rho_dm_i_1, potential_object)
        _, result_2 = integrate_cosmo(ic, a_ini, a_end, n_steps, rho_dm_i_2, potential_object)
        _, omega_c_2 = find_present_day_fractions(result_2, a_ini, rho_dm_i_2, potential_object)

        if abs(omega_c_2 - omega_c_1) < 1e-10: break
        slope = (omega_c_2 - omega_c_1) / (rho_dm_i_2 - rho_dm_i_1)
        if abs(slope) < 1e-10: break

        rho_dm_i_next = rho_dm_i_2 - (omega_c_2 - omega_c_target) / slope
        if abs(omega_c_2 - omega_c_target) < 1e-5:
            converged = True
            break
        rho_dm_i_1, rho_dm_i_2 = rho_dm_i_2, rho_dm_i_next
    
    if converged:
        return rho_dm_i_2

    # --- Attempt 2: Bisection Method (Fallback) --- 
    logging.warning("Inner loop (rho_dm_i) secant method failed. Switching to bisection.")
    rho_dm_i_1 = rho_dm_i_guess_base * 0.5
    rho_dm_i_2 = rho_dm_i_guess_base * 1.5
    
    _, r1 = integrate_cosmo(ic, a_ini, a_end, n_steps, rho_dm_i_1, potential_object)
    _, omega_c_1 = find_present_day_fractions(r1, a_ini, rho_dm_i_1, potential_object)
    _, r2 = integrate_cosmo(ic, a_ini, a_end, n_steps, rho_dm_i_2, potential_object)
    _, omega_c_2 = find_present_day_fractions(r2, a_ini, rho_dm_i_2, potential_object)
    
    if (omega_c_1 - omega_c_target) * (omega_c_2 - omega_c_target) >= 0:
        raise RuntimeError("Inner loop bisection failed: initial guesses do not bracket the solution.")
        
    for _ in range(20):
        rho_dm_i_mid = (rho_dm_i_1 + rho_dm_i_2) / 2
        _, result_mid = integrate_cosmo(ic, a_ini, a_end, n_steps, rho_dm_i_mid, potential_object)
        _, omega_c_mid = find_present_day_fractions(result_mid, a_ini, rho_dm_i_mid, potential_object)
        
        if abs(omega_c_mid - omega_c_target) < 1e-5:
            return rho_dm_i_mid
            
        if (omega_c_mid - omega_c_target) * (omega_c_1 - omega_c_target) < 0:
            rho_dm_i_2 = rho_dm_i_mid
        else:
            rho_dm_i_1 = rho_dm_i_mid
            
    return rho_dm_i_mid

def solve_system(
    ic_phi: float, ic_phi_prime: float, a_ini: float, a_end: float, n_steps: int,
    potential_flag: int, initial_params: Dict[str, Any], param_to_shoot: str,
    guess_1: float, guess_2: float
) -> Tuple[np.ndarray, np.ndarray, ScalarPotential, float]:
    """
    OUTER LOOP: Solves the system using a nested shooting method with a bisection fallback.
    """
    logging.info(f"--- Starting Nested Shooting for Potential Flag {potential_flag} ---")
    logging.info(f"Shooting for parameter '{param_to_shoot}' to match omega_de_target = {omega_de_target:.5f}")
    
    ic = [ic_phi, ic_phi_prime]
    PotentialClass = potential_factory[potential_flag]
    
    p1, p2 = guess_1, guess_2
    params1, params2 = initial_params.copy(), initial_params.copy()
    params1[param_to_shoot], params2[param_to_shoot] = p1, p2
    potential1, potential2 = PotentialClass(**params1), PotentialClass(**params2)

    rho_dm_i1 = _shoot_for_rho_dm_i(ic, a_ini, a_end, n_steps, potential1)
    a, result1 = integrate_cosmo(ic, a_ini, a_end, n_steps, rho_dm_i1, potential1)
    omega_de1, _ = find_present_day_fractions(result1, a_ini, rho_dm_i1, potential1)

    rho_dm_i2 = _shoot_for_rho_dm_i(ic, a_ini, a_end, n_steps, potential2)
    _, result2 = integrate_cosmo(ic, a_ini, a_end, n_steps, rho_dm_i2, potential2)
    omega_de2, _ = find_present_day_fractions(result2, a_ini, rho_dm_i2, potential2)

    logging.info(f"Initial Guess 1: {param_to_shoot}={p1:.4e} -> omega_de={omega_de1:.5f}")
    logging.info(f"Initial Guess 2: {param_to_shoot}={p2:.4e} -> omega_de={omega_de2:.5f}")

    # --- Attempt 1: Secant Method ---
    converged = False
    final_result, final_potential, final_rho_dm_i = result2, potential2, rho_dm_i2
    for i in range(20):
        if abs(p2 - p1) < 1e-10: break
        slope = (omega_de2 - omega_de1) / (p2 - p1)
        if abs(slope) < 1e-10: break
        
        p_next = p2 - (omega_de2 - omega_de_target) / slope
        params_next = initial_params.copy(); params_next[param_to_shoot] = p_next
        potential_next = PotentialClass(**params_next)
        
        rho_dm_i_next = _shoot_for_rho_dm_i(ic, a_ini, a_end, n_steps, potential_next)
        a, result_next = integrate_cosmo(ic, a_ini, a_end, n_steps, rho_dm_i_next, potential_next)
        omega_de_next, omega_c_final = find_present_day_fractions(result_next, a_ini, rho_dm_i_next, potential_next)
        
        error = (omega_de_next - omega_de_target) / omega_de_target
        logging.info(f"Iter {i+1} (Secant): {param_to_shoot}={p_next:.4e} -> omega_de={omega_de_next:.5f} (err={error:.2e})")

        final_result, final_potential, final_rho_dm_i = result_next, potential_next, rho_dm_i_next
        if abs(error) < 1e-4:
            logging.info("--- Secant Method Converged Successfully! ---")
            converged = True
            break
        p1, p2, omega_de1, omega_de2 = p2, p_next, omega_de2, omega_de_next

    if converged:
        return a, final_result, final_potential, final_rho_dm_i

    # --- Attempt 2: Bisection Method (Fallback) ---
    logging.warning("Outer loop secant method failed. Switching to bisection.")
    if (omega_de1 - omega_de_target) * (omega_de2 - omega_de_target) >= 0:
        raise RuntimeError(f"Outer loop bisection failed: initial guesses do not bracket the solution for {param_to_shoot}. "
                         f"omega_de results were {omega_de1:.5f} and {omega_de2:.5f} for target {omega_de_target:.5f}")

    p1, p2 = guess_1, guess_2 # Reset to original guesses
    for i in range(40): # More iterations for bisection
        p_mid = (p1 + p2) / 2
        params_mid = initial_params.copy(); params_mid[param_to_shoot] = p_mid
        potential_mid = PotentialClass(**params_mid)
        
        rho_dm_i_mid = _shoot_for_rho_dm_i(ic, a_ini, a_end, n_steps, potential_mid)
        a, result_mid = integrate_cosmo(ic, a_ini, a_end, n_steps, rho_dm_i_mid, potential_mid)
        omega_de_mid, _ = find_present_day_fractions(result_mid, a_ini, rho_dm_i_mid, potential_mid)

        error = (omega_de_mid - omega_de_target) / omega_de_target
        logging.info(f"Iter {i+1} (Bisection): {param_to_shoot}={p_mid:.4e} -> omega_de={omega_de_mid:.5f} (err={error:.2e})")

        if abs(error) < 1e-4:
            logging.info("--- Bisection Method Converged Successfully! ---")
            return a, result_mid, potential_mid, rho_dm_i_mid

        if (omega_de_mid - omega_de_target) * (omega_de1 - omega_de_target) < 0:
            p2, omega_de2 = p_mid, omega_de_mid
        else:
            p1, omega_de1 = p_mid, omega_de_mid
            
    raise RuntimeError("Both secant and bisection methods failed to converge.")

# =============================================================================
# 5. Auxiliary structures
# =============================================================================

def calculate_derived_quantities(
    a: np.ndarray, result: np.ndarray, a_ini: float, rho_dm_i: float, potential_object: ScalarPotential
) -> Dict[str, np.ndarray]:
    """
    Post-processes the simulation results to calculate key physical quantities.
    """
    phi_arr, phi_prime_arr = result.T
    phi_i = result[0, 0]

    # Calculate all derived quantities as arrays over the cosmic time (a)
    V_of_phi = potential_object.value(phi_arr)
    rho_dm_arr = rho_dm_i * (phi_arr / phi_i) * (a_ini / a)**3
    rho_phi_arr = 0.5 * phi_prime_arr**2 / (a**2) + V_of_phi
    rho_r_arr = rho_cr * omega_r * a**(-4)
    rho_b_arr = rho_cr * omega_b * a**(-3)
    
    H_curly_arr = np.array([H_curly(y, val_a, val_rho_dm, potential_object)
                            for y, val_a, val_rho_dm in zip(result, a, rho_dm_arr)])

    epsilon = 1e-40
    rho_phi_safe = np.where(np.abs(rho_phi_arr) < epsilon, epsilon, rho_phi_arr)
    phi_safe = np.where(np.abs(phi_arr) < epsilon, epsilon, phi_arr)
    H_curly_safe = np.where(np.abs(H_curly_arr) < epsilon, epsilon, H_curly_arr)

    w_phi = (0.5 * phi_prime_arr**2 / (a**2) - V_of_phi) / rho_phi_safe
    interaction = -rho_dm_arr / phi_safe
    coupling = (phi_prime_arr / (3 * H_curly_safe * phi_safe)) * (rho_dm_arr / rho_phi_safe)
    w_eff = w_phi + coupling

    # --- Calculate Effective Potential ---
    # The total "force" on the field is dV/dphi + interaction_term
    dV_dphi_arr = potential_object.derivative(phi_arr)
    interaction_force_arr = rho_dm_arr / phi_safe
    total_force_arr = dV_dphi_arr + interaction_force_arr
    
    # To integrate wrt phi, we must sort by phi as it may not be monotonic
    sort_indices = np.argsort(phi_arr)
    phi_sorted = phi_arr[sort_indices]
    force_sorted = total_force_arr[sort_indices]
    
    # Integrate and then unsort back to the original time-ordered sequence
    V_eff_integrated_sorted = cumulative_trapezoid(force_sorted, phi_sorted, initial=0)
    # Set the constant of integration so V_eff = V at the start
    V_eff_integrated_sorted += V_of_phi[sort_indices][0] - V_eff_integrated_sorted[0]
    
    unsort_indices = np.argsort(sort_indices)
    V_eff_arr = V_eff_integrated_sorted[unsort_indices]

    return {
        "a": a,
        "phi": phi_arr,
        "phi_prime": phi_prime_arr,
        "V_of_phi": V_of_phi,
        "V_eff": V_eff_arr,
        "rho_dm": rho_dm_arr,
        "rho_phi": rho_phi_arr,
        "rho_r": rho_r_arr,
        "rho_b": rho_b_arr,
        "H_curly": H_curly_arr,
        "w_phi": w_phi,
        "interaction": interaction,
        "coupling": coupling,
        "w_eff": w_eff,
    }

def run_full_simulation(
    potential_flag: int, params_vector_to_shoot: Dict[str, Any],
    a_ini: float, a_end: float, n_steps: int, phi_i: float, phi_prime_i: float,
    default_guesses: Dict[str, List[float]]
) -> Dict[str, Any]:
    """
    High-level wrapper that configures and runs the entire simulation.
    """
    # 1. Parse the parameter vector to find which parameter to shoot for
    param_to_shoot = None
    initial_params = {}
    for key, value in params_vector_to_shoot.items():
        if value is True:
            param_to_shoot = key
        else:
            initial_params[key] = value
    
    if param_to_shoot is None:
        raise ValueError("Shooting parameter not specified. Set one parameter to `True`.")

    # 2. Get shooting guesses from the provided dictionary
    if param_to_shoot not in default_guesses:
        raise NotImplementedError(f"No default shooting guesses configured for parameter '{param_to_shoot}'")
    guess1, guess2 = default_guesses[param_to_shoot]

    # 3. Run the solver
    a, result, potential_obj, rho_dm_i_final = solve_system(
        ic_phi=phi_i, ic_phi_prime=phi_prime_i, a_ini=a_ini, a_end=a_end, n_steps=n_steps,
        potential_flag=potential_flag, initial_params=initial_params,
        param_to_shoot=param_to_shoot, guess_1=guess1, guess_2=guess2
    )

    # 4. Post-process the results
    derived_quantities = calculate_derived_quantities(
        a, result, a_ini, rho_dm_i_final, potential_obj
    )
    
    # 5. Add initial conditions and final potential to results for plotting
    derived_quantities['potential_object'] = potential_obj
    derived_quantities['initial_conditions'] = {
        'phi_i': phi_i,
        'phi_prime_i': phi_prime_i,
        'a_ini': a_ini
    }
    return derived_quantities

def find_critical_point(scale_factor_arr: np.ndarray, phi_prime_arr: np.ndarray) -> float:
    """
    Calculates the critical point for the scalar field derivative where it changes sign.
    Returns 0.0 if no such crossing is found.
    """
    idx = np.where(np.diff(np.sign(phi_prime_arr)))[0]
    if len(idx) > 0:
        c = idx[0]
        a_c = (scale_factor_arr[c] + scale_factor_arr[c+1]) / 2
        return a_c
    return 0.0

def find_w_phi_critical_points(w_phi: np.ndarray) -> np.ndarray:
    """
    Finds the indices of critical points (local maxima and minima) of the w_phi array.
    """
    # Calculate the sign of the discrete derivative of w_phi
    deriv_sign = np.sign(np.diff(w_phi))
    # Find indices where the sign changes (e.g., from +1 to -1 or vice-versa)
    # We add 1 to the index because np.diff reduces the array length by one.
    critical_indices = np.where(np.diff(deriv_sign) != 0)[0] + 1
    return critical_indices

def find_all_phantom_crossings(a: np.ndarray, w_eff: np.ndarray) -> List[Tuple[float, float]]:
    """
    Detects all instances where w_eff crosses the -1 line (phantom crossings).
    Returns a list of (crossing_a, crossing_z) tuples.
    """
    crossings = []
    # Look for a sign change from w_eff > -1 to w_eff < -1 OR w_eff < -1 to w_eff > -1
    # We need to ensure w_eff is defined and not NaN
    valid_indices = np.where(~np.isnan(w_eff))
    a_valid = a[valid_indices]
    w_eff_valid = w_eff[valid_indices]

    for i in range(1, len(w_eff_valid)):
        # Check for crossing -1 in either direction
        if (w_eff_valid[i-1] > -1 and w_eff_valid[i] < -1) or \
           (w_eff_valid[i-1] < -1 and w_eff_valid[i] > -1):
            a1, a2 = a_valid[i-1], a_valid[i]
            w1, w2 = w_eff_valid[i-1], w_eff_valid[i]

            if (w2 - w1) != 0: # Avoid division by zero if w_eff is flat
                crossing_a = a1 + (-1 - w1) * (a2 - a1) / (w2 - w1)
                crossing_z = (1 / crossing_a) - 1
                crossings.append((crossing_a, crossing_z))
    return crossings

# =============================================================================
# 6. Plotting functions
# =============================================================================

def plot_eos_eff(results: Dict[str, Any], 
                 show_phantom_crossings=True, 
                 show_eos=True, 
                 show_critical_points=True,
                 xlim: Optional[List[float]] = None,
                 ylim: Optional[List[float]] = None,
                 use_redshift=False,
                 show_initial_parameters=True,
                 show_phantom_redshifts=True,
                 show_phantom_phase=False,
                 plot_potential_together=False,
                 plot_effective_potential=False,
                 plot_field_evolution=False,
                 show_V_x_phi=False
                 ) -> None:
    """
    Plots the effective equation of state and, optionally, the potential evolution.
    """
    logging.info("--- Plotting Results ---")
    
    # --- Setup Figure: Determine number of panels ---
    num_panels = 1
    if plot_potential_together:
        num_panels += 1
    if show_V_x_phi:
        num_panels += 1

    if num_panels == 1:
        fig, ax1 = plt.subplots(figsize=(12, 7))
        ax2, ax3 = None, None
    elif num_panels == 2:
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7))
        ax3 = None
    else: # num_panels == 3
        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(24, 7))

    # --- Setup X-axis for time-evolution plots ---
    if use_redshift:
        x_data = 1 / results['a'] - 1
        xlabel = "Redshift (z)"
        ax1.invert_xaxis()
        if ax2: ax2.invert_xaxis()
    else:
        x_data = results['a']
        xlabel = "Scale Factor (a)"

    # --- PANEL 1: Equation of State Plot ---
    if show_eos:
        ax1.plot(x_data, results['w_phi'], label=r'$w_{\phi}$ (DE only)', linestyle=':')
    ax1.plot(x_data, results['w_eff'], label=r'$w_{eff}$ (DE + Interaction)', color='black')
    ax1.axhline(-1, color='red', linestyle='--', linewidth=1, label='Phantom Divide ($w=-1$)')

    if show_phantom_phase:
        ax1.fill_between(x_data, results['w_eff'], -1, where=results['w_eff'] < -1, 
                         color='red', alpha=0.2, label='Phantom Phase')

    if show_phantom_crossings:
        crossings = find_all_phantom_crossings(results['a'], results['w_eff'])
        for i, (crossing_a, crossing_z) in enumerate(crossings):
            x_crossing = crossing_z if use_redshift else crossing_a
            ax1.axvline(x_crossing, color='purple', linestyle='-.', alpha=0.7, 
                        label='Phantom Crossing' if i == 0 else "")
            if show_phantom_redshifts:
                ax1.text(x_crossing * 1.1, ax1.get_ylim()[0] * 0.1, f'z={crossing_z:.2f}', 
                         color='purple', rotation=90)

    if show_critical_points:
        crit_indices = find_w_phi_critical_points(results['w_phi'])
        if len(crit_indices) > 0:
            x_crit = x_data[crit_indices]
            y_crit = results['w_phi'][crit_indices]
            ax1.scatter(x_crit, y_crit, marker='o', s=80, facecolors='none', edgecolors='green',
                        zorder=5, label=r'Critical Points of $w_{\phi}$')

    if xlim: ax1.set_xlim(xlim)
    if ylim: ax1.set_ylim(ylim)
    else: ax1.set_ylim(-1.5, 1.2)
    
    ax1.set_xlabel(xlabel)
    ax1.set_ylabel("Equation of State (w)")
    ax1.set_title(f"Equation of State Evolution")
    if not use_redshift: ax1.set_xscale('log')
    ax1.grid(True, which='both', linestyle='--', linewidth=0.5)

    # --- Legend Handling ---
    handles, labels = ax1.get_legend_handles_labels()
    if show_initial_parameters:
        ic = results['initial_conditions']
        ic_text = (
            f"Initial Conditions:\n"
            fr"  $a_i = {ic['a_ini']:.1e}$"
            fr", $\phi_i = {ic['phi_i']}$"
            fr", $\phi'_i = {ic['phi_prime_i']}$"
            fr", $\alpha={global_alpha}$" + "\n"
        )
        extra = Rectangle((0, 0), 1, 1, fc="w", fill=False, edgecolor='none', linewidth=0)
        handles.append(extra)
        labels.append(ic_text)
    
    if num_panels > 1:
        ax1.legend(handles, labels, loc='best')
    else:
        ax1.legend(handles, labels, loc='center left', bbox_to_anchor=(1, 0.5))
        fig.subplots_adjust(right=0.7)

    # --- PANEL 2: Potential Evolution Plot (Optional) ---
    if plot_potential_together and ax2:
        crit_indices_pot = find_w_phi_critical_points(results['V_of_phi'])
        if len(crit_indices_pot) > 0:
            x_crit_pot = x_data[crit_indices_pot]
            y_crit_pot = results['V_of_phi'][crit_indices_pot] / results['V_of_phi'][0]
            ax2.scatter(x_crit_pot, y_crit_pot, marker='o', s=80, facecolors='none', edgecolors='green',
                        zorder=5, label=r'Critical Points of $V({\phi}) / V_0$')
        V_normalized = results['V_of_phi'] / results['V_of_phi'][0]
        p1, = ax2.plot(x_data, V_normalized, color='darkorange', linestyle='--', label=r'$V/V_i$')
        ax2.set_ylabel(r'Normalized Potential $V/V_i$', color='darkorange')
        ax2.tick_params(axis='y', labelcolor='darkorange')
        #ax2.set_yscale('log')
        ax2.set_xscale('log')

        if plot_effective_potential:
            if 'V_eff' in results:
                ax2.loglog(x_data, results['V_eff'], color='darkorange', label=r'$V_{eff}(\phi)$ (Effective)')
            else:
                logging.warning("Effective potential data not found in results; skipping its plot.")
        
        lines = [p1]
        if plot_field_evolution:
            # Create a twin axis for phi/phi_i
            ax2b = ax2.twinx()
            phi_normalized = results['phi'] / results['phi'][0]
            p2, = ax2b.plot(x_data, phi_normalized, color='blue', linestyle=':', label=r'$\phi/\phi_i$')
            ax2b.set_ylabel(r'Normalized Field $\phi/\phi_i$', color='blue')
            ax2b.tick_params(axis='y', labelcolor='blue')
            lines.append(p2)

        if show_phantom_phase:
            is_phantom = results['w_eff'] < -1
            phantom_boundaries = np.diff(np.concatenate(([False], is_phantom, [False])).astype(int))
            start_indices = np.where(phantom_boundaries == 1)[0]
            end_indices = np.where(phantom_boundaries == -1)[0]
            
            has_phantom_label = False
            for start_idx, end_idx in zip(start_indices, end_indices):
                label = 'Phantom Phase' if not has_phantom_label else ''
                if start_idx < len(x_data) and end_idx <= len(x_data):
                    ax2.axvspan(x_data[start_idx], x_data[end_idx - 1], color='red', alpha=0.2, label=label)
                    has_phantom_label = True
        
        ax2.set_xlabel(xlabel)
        ax2.set_title('Potential & Field Evolution')
        if not use_redshift: ax2.set_xscale('log')
        ax2.grid(True, which='both', linestyle='--', linewidth=0.5)
        ax2.legend(lines, [l.get_label() for l in lines], loc='best')

    # --- PANEL 3: V(phi) vs phi Plot (Optional) ---
    if show_V_x_phi and ax3:
        phi_arr = results['phi']
        V_normalized = results['V_of_phi'] / results['V_of_phi'][0]
        ax3.plot(phi_arr, V_normalized, color='purple', label=r'$V(\phi)/V_i$')

        if show_phantom_phase:
            is_phantom = results['w_eff'] < -1
            # Find transitions into and out of the phantom phase
            phantom_boundaries = np.diff(np.concatenate(([False], is_phantom, [False])).astype(int))
            start_indices = np.where(phantom_boundaries == 1)[0]
            end_indices = np.where(phantom_boundaries == -1)[0]
            
            has_phantom_label = False
            for start_idx, end_idx in zip(start_indices, end_indices):
                label = 'Phantom Phase' if not has_phantom_label else ''
                # Shade based on the phi values during the phantom phase
                if start_idx < len(phi_arr) and end_idx <= len(phi_arr):
                    ax3.fill_betweenx(ax3.get_ylim(), phi_arr[start_idx], phi_arr[end_idx - 1], color='red', alpha=0.2, label=label)
                    has_phantom_label = True

        ax3.set_xlabel(r'Field Value $\phi$')
        ax3.set_ylabel(r'Normalized Potential $V(\phi)/V_i$')
        ax3.set_title(r'Field Path in Potential')
        ax3.set_yscale('log')
        ax3.legend()
        ax3.grid(True, which='both', linestyle='--', linewidth=0.5)

    # --- Final Figure Setup ---
    fig.suptitle(f"Cosmological Evolution for {results['potential_object']}", fontsize=16)
    plt.show()

def plot_sweep_results(results_list: List[Dict[str, Any]], sweep_parameter: str, use_redshift: bool = False, x_lim=None, y_lim=None) -> None:
    """
    Plots the results from a parameter sweep on a single graph.
    """
    logging.info(f"--- Plotting Sweep Results for parameter '{sweep_parameter}' ---")
    fig, ax = plt.subplots(figsize=(12, 7))

    # --- Setup X-axis: Redshift or Scale Factor ---
    if use_redshift:
        xlabel = "Redshift (z)"
    else:
        xlabel = "Scale Factor (a)"

    # --- Plot data from each simulation in the sweep ---
    for i, results in enumerate(results_list):
        if use_redshift:
            x_data = 1 / results['a'] - 1
        else:
            x_data = results['a']
        
        # Create a label for this specific run. This logic is now corrected.
        sweep_val = results['initial_conditions'][sweep_parameter]
        # Robustly create LaTeX label
        parts = sweep_parameter.split('_')
        if len(parts) == 2:
            latex_name = fr"\{parts[0]}_{{{parts[1]}}}"
        else:
            latex_name = sweep_parameter
        
        label = fr'$w_{{eff}}$ for ${latex_name} = {sweep_val}$'
        ax.plot(x_data, results['w_eff'], label=label)

    # --- Final plot setup ---
    ax.axhline(-1, color='red', linestyle='--', linewidth=1, label='Phantom Divide ($w=-1$)')
    if use_redshift:
        ax.invert_xaxis()
    else:
        ax.set_xscale('log')
        
    ax.set_xlabel(xlabel)
    ax.set_ylabel("Effective Equation of State ($w_{eff}$)")
    ax.set_title(f"Parameter Sweep for '{sweep_parameter}'\n{results_list[0]['potential_object'].name} Potential")
    if x_lim:
        ax.set_xlim(x_lim)
    if y_lim:
        ax.set_ylim(y_lim)
    ax.legend(loc='best')
    ax.grid(True, which='both', linestyle='--', linewidth=0.5)
    # plt.tight_layout()
    plt.show()

def plot_background_species(results: Dict[str, Any], use_redshift=False, xlim=None, ylim=None, compare_with_LCDM=False) -> None:
    """
    Plots the evolution of the density parameters (Omega) for each cosmic species.
    """
    logging.info("--- Plotting Background Species Evolution ---")
    fig, ax = plt.subplots(figsize=(12, 8))

    a = results['a']
    
    # --- Calculate total density from the simulation ---
    # Note: Using the individual densities from results ensures consistency
    rho_total = results['rho_r'] + results['rho_b'] + results['rho_dm'] + results['rho_phi']

    # --- Calculate Omega for each species from the simulation ---
    omega_rad = results['rho_r'] / rho_total
    omega_baryon = results['rho_b'] / rho_total
    omega_dm = results['rho_dm'] / rho_total
    omega_de = results['rho_phi'] / rho_total

    # --- Setup X-axis ---
    if use_redshift:
        x_data = 1 / a - 1
        xlabel = "Redshift (z)"
        ax.invert_xaxis()
    else:
        x_data = a
        xlabel = "Scale Factor (a)"
        ax.set_xscale('log')

    # --- Plot the species from the simulation ---
    ax.plot(x_data, omega_rad, label=r'$\Omega_r$ (Radiation)', color='red')
    ax.plot(x_data, omega_baryon, label=r'$\Omega_b$ (Baryons)', color='blue')
    ax.plot(x_data, omega_dm, label=r'$\Omega_{dm}$ (Dark Matter)', color='green')
    ax.plot(x_data, omega_de, label=r'$\Omega_{de}$ (Dark Energy)', color='purple')

    # --- Compare with LCDM if requested ---
    if compare_with_LCDM:
        # Calculate the Hubble parameter squared for a standard LCDM model
        # The total matter density parameter is omega_b + omega_c (baryons + cold dark matter)
        H2_lcdm_over_H02 = (omega_r * a**-4 + (omega_b + omega_c_target) * a**-3 + omega_de_target)
        
        # Calculate LCDM Omegas by dividing each component's evolution by the total
        omega_r_lcdm = (omega_r * a**-4) / H2_lcdm_over_H02
        omega_m_lcdm = ((omega_b + omega_c_target) * a**-3) / H2_lcdm_over_H02
        omega_de_lcdm = omega_de_target / H2_lcdm_over_H02
        
        # Plot LCDM curves
        ax.plot(x_data, omega_r_lcdm, color='black', linestyle='--', lw=1, label='ΛCDM')
        ax.plot(x_data, omega_m_lcdm, color='black', linestyle='--', lw=1)
        ax.plot(x_data, omega_de_lcdm, color='black', linestyle='--', lw=1)


    # --- Final plot setup ---
    ax.set_xlabel(xlabel)
    ax.set_ylabel(r'Density Parameter ($\Omega$)')
    ax.set_title('Evolution of Cosmic Species')
    ax.legend(loc='best')
    ax.grid(True, which='both', linestyle='--', linewidth=0.5)

    if xlim:
        ax.set_xlim(xlim)
    if ylim:
        ax.set_ylim(ylim)
    else:
        ax.set_ylim(0, 1.1)

    # plt.tight_layout()
    plt.show()

# This dictionary maps an integer flag to the corresponding potential class.
# To add a new potential, define its class and then add an
# entry to this dictionary.
potential_factory: Dict[int, Type[ScalarPotential]] = {
        1: ConstantPotential,
        2: ExponentialPotential,
        3: PowerLawPotential,
        4: GaussianPotential,
        5: InversePowerLawPotential 
    }

if __name__ == '__main__':

    #Flags to display simulations
    PLOT_EQUATION_OF_STATE = True
    PLOT_FIELD_EVOLUTION = True
    PLOT_BACKGROUND_EVOLUTION_SPECIES = False
    
    # --- Control Parameter Sweep ---
    # Set to a string like 'phi_i' or 'phi_prime_i' to activate sweep mode.
    # Set to None to run a single simulation.
    sweep_parameter = None
    sweep_values = [0, 1e1, 1e2, 1e3]
   
    # --- Set Initial Simulation Parameters ---
    potential_flag = 4

    a_ini = 1e-4
    a_end = 1.0
    n_steps = 50000
    phi_i_base = 10
    phi_prime_i_base = 0.07*0

    
    # params_vector_to_shoot = {'A': True, 'B': 0.001} # This one is interesting for Inverse Power Law potential
    # params_vector_to_shoot = {'A': True, 'B': -0.23} # This one is interesting for Exponential potential
    params_vector_to_shoot = {'A': True, 'B': 1/phi_i_base**2, 'C': 0} # This one is interesting for Gaussian potential
    # params_vector_to_shoot = {'V0': True} # bissection is not working properly here, need to check

    default_guesses = {
        'V0': [rho_cr * omega_de_target * 0.8, rho_cr * omega_de_target * 1.2], # Standard guessses, we know it works
        'A':  [rho_cr * omega_de_target * 0.8, rho_cr * omega_de_target * 1.2], # For exponential potential: A = [1e-7, 1e-8], B = [-0.05, 0.05], these usually work for secant method
        'B':  [-1e5, 1e5],
        'C':  [1e-7, 1e-8]
    }
    
    # --- Main Execution Logic: Single Run vs. Parameter Sweep ---
    if sweep_parameter is None:
        # --- Single Simulation Run ---
        try:
            results = run_full_simulation(
                potential_flag=potential_flag,
                params_vector_to_shoot=params_vector_to_shoot,
                a_ini=a_ini, a_end=a_end, n_steps=n_steps,
                phi_i=phi_i_base, phi_prime_i=phi_prime_i_base,
                default_guesses=default_guesses
            )

            print("\n--- Final Converged Solution & Results ---")
            print(f"Final Potential: {results['potential_object']}")
            
            if PLOT_EQUATION_OF_STATE:
                plot_eos_eff(results, 
                             use_redshift=True, 
                             show_phantom_phase=True, 
                             xlim=[0, 5], ylim=[-1.5, -0.6], 
                             plot_potential_together=True, 
                             plot_effective_potential=False,
                             plot_field_evolution=PLOT_FIELD_EVOLUTION,
                             show_V_x_phi=False)
            
            if PLOT_BACKGROUND_EVOLUTION_SPECIES:
                plot_background_species(results, compare_with_LCDM=True)

        except (RuntimeError, NotImplementedError, ValueError) as e:
            logging.error(f"Single simulation failed: {e}")
    else:
        # --- Parameter Sweep Run ---
        logging.info(f"--- Starting Parameter Sweep for '{sweep_parameter}' ---")
        all_results = []
        
        # Prepare a dictionary of the base parameters
        sim_params = {
            'potential_flag': potential_flag,
            'params_vector_to_shoot': params_vector_to_shoot,
            'a_ini': a_ini, 'a_end': a_end, 'n_steps': n_steps,
            'phi_i': phi_i_base, 'phi_prime_i': phi_prime_i_base,
            'default_guesses': default_guesses
        }

        for value in sweep_values:
            logging.info(f"\n--- Running for {sweep_parameter} = {value} ---")
            # Update the sweep parameter for this specific run
            sim_params[sweep_parameter] = value
            try:
                results = run_full_simulation(**sim_params)
                all_results.append(results)
            except (RuntimeError, NotImplementedError, ValueError) as e:
                logging.error(f"Simulation failed for {sweep_parameter} = {value}: {e}")
        
        # After all simulations are done, plot the combined results
        if all_results:
            plot_sweep_results(all_results, sweep_parameter, use_redshift=True)
