import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import numpy as np
import logging
from typing import List, Dict, Any, Optional
from scipy.interpolate import interp1d

# --- Fixed cosmological parameters from Planck 2018 ---
# --- Using CAMB units ---
c_in_km_s = 299_792.458
h = 0.6756
H0 = 100*h/c_in_km_s
rho_cr = 3*H0**2
omega_c = 0.12/h**2
omega_b = 0.022/h**2
omega_phot = 2.47e-5/h**2
omega_massless_nu = 3*(7/8)*(4/11)**(4/3)*omega_phot
omega_r = omega_phot + omega_massless_nu
omega_de = 1 - omega_c - omega_b - omega_r
omega_de_target = omega_de
omega_c_target = omega_c

# -- For Camb --
import camb

h_main, omegabh2_main, omegach2_main = 0.6756, 0.022, 0.120
As_main, ns_main = 2.1e-9, 0.965

# -- DESI central values ---
w0_desi = -0.727
wa_desi = -1.05
global_alpha = 1

# -- Global simulation parameters ---
a_ini = 1e-5 # Fixed for CAMB 
a_end = 1.0
n_steps = 50000
phi_i_base = 30.0
phi_prime_i_base = 0
default_guesses = {'V0': [rho_cr * omega_de_target * 0.8, rho_cr * omega_de_target * 1.2]}

# -- Results from HDS (ODEINT-Based) --

from HDSSolver import global_alpha, find_all_phantom_crossings, find_w_phi_critical_points, run_full_simulation

results_HDS = run_full_simulation(
                    potential_flag=1, # CAMB has only constant potential implemented
                    params_vector_to_shoot={'V0': True},
                    a_ini=a_ini, a_end=a_end, n_steps=n_steps,
                    phi_i=phi_i_base, phi_prime_i=phi_prime_i_base,
                    default_guesses=default_guesses
                )

# -- Results from CAMB --
params = camb.set_params(
        H0=100 * h_main, ombh2=omegabh2_main, omch2=omegach2_main, TCMB=2.7255,
        dark_energy_model='HybridQuintessence',
        phi_i=phi_i_base, phi_prime_i=phi_prime_i_base, alpha=global_alpha,
        omnuh2=0, num_nu_massless=3.044, num_nu_massive=0,
        nu_mass_degeneracies=[0], nu_mass_numbers=[0],
        As=As_main, ns=ns_main, tau=0.0544,
        YHe=0.246, WantTransfer=True
    )
params.NonLinear = camb.model.NonLinear_none

results_camb = camb.get_results(params)

scale_factor_arr = results_HDS['a'] # using same array for both results

rhos = results_camb.get_background_densities(scale_factor_arr)
H = scale_factor_arr * results_camb.h_of_z(1 / scale_factor_arr - 1)
H_curly = H * scale_factor_arr  # Conformal Hubble parameter
_, w_de = results_camb.get_dark_energy_rho_w(scale_factor_arr)
rho_de = rhos['de']
rho_cdm = rhos['cdm'] 
rho_b = rhos['baryon']
rho_phot = rhos['photon']
rho_nu = rhos['neutrino']
rho_rad = rho_phot + rho_nu

de = results_camb.Params.DarkEnergy

phi_interpolator = interp1d(de.sampled_a, de.phi_a, bounds_error=False, fill_value="extrapolate")
phi_prime_interpolator = interp1d(de.sampled_a, de.phidot_a, bounds_error=False, fill_value="extrapolate")

phi = phi_interpolator(scale_factor_arr)
phi_prime = phi_prime_interpolator(scale_factor_arr) # getting weird values here

V_of_phi = np.full_like(phi, de.V0) # Only for constant potential
dV_dphi_arr = np.zeros_like(phi) # Only for constant potential

coupling_term = global_alpha * phi_prime * rho_cdm / (phi * 3 * H * rho_de)

w_eff = w_de + coupling_term

results_camb_dict = {
    'a': scale_factor_arr,
    'phi': phi,
    'phi_prime': phi_prime,
    'V_of_phi': V_of_phi,
    'dV_dphi': dV_dphi_arr,
    'rho_de': rho_de,
    'rho_cdm': rho_cdm,
    'rho_b': rho_b,
    'rho_rad': rho_rad,
    'H': H,
    'H_curly': H_curly,
    'w_phi': w_de,
    'w_eff': w_eff,
    'potential_object': 'Constant Potential (CAMB)',
    'initial_conditions': {
        'a_ini': a_ini,
        'phi_i': phi_i_base,
        'phi_prime_i': phi_prime_i_base
    }
}

# -- Plotting --

def compare_eos(results_camb: Dict[str, Any] = results_camb_dict,
                 results_hds: Dict[str, Any] = results_HDS, 
                 show_phantom_crossings=True, 
                 show_critical_points=True,
                 xlim: Optional[List[float]] = None,
                 ylim: Optional[List[float]] = None,
                 use_redshift=False,
                 show_initial_parameters=True,
                 show_phantom_redshifts=True,
                 show_phantom_phase=True,
                 ) -> None:
    """
    Plots the effective equation of state from both CAMB and HDS results for comparison.
    """
    logging.info("--- Plotting Results ---")
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7), sharey=True, sharex=True)
    
    # --- Setup X-axis for time-evolution plots ---
    if use_redshift:
        x_data = 1 / results_hds['a'] - 1
        xlabel = "Redshift (z)"
        ax1.invert_xaxis()
        if ax2: ax2.invert_xaxis()
    else:
        x_data = results_hds['a']
        xlabel = "Scale Factor (a)"
    
    ax1.plot(x_data, results_hds['w_phi'], label=r'$w_{\phi}$ (DE only)', linestyle=':')
    ax1.plot(x_data, results_hds['w_eff'], label=r'$w_{eff}$', linestyle=':')
    ax1.axhline(-1, color='red', linestyle='--', linewidth=1, label='Phantom Divide ($w=-1$)')
    ax1.set_title('HDS Results')

    ax2.plot(x_data, results_camb['w_phi'], label=r'$w_{\phi}$ (DE only)', linestyle=':')
    ax2.plot(x_data, results_camb['w_eff'], label=r'$w_{eff}$', linestyle=':')
    ax2.axhline(-1, color='red', linestyle='--', linewidth=1, label='Phantom Divide ($w=-1$)')
    ax2.set_title('CAMB Results')

    if show_phantom_phase:
        ax1.fill_between(x_data, results_hds['w_eff'], -1, where=results_hds['w_eff'] < -1, 
                         color='red', alpha=0.2, label='Phantom Phase')
        ax2.fill_between(x_data, results_camb['w_eff'], -1, where=results_camb['w_eff'] < -1, 
                         color='red', alpha=0.2, label='Phantom Phase')

    if show_critical_points:
        crit_indices = find_w_phi_critical_points(results_hds['w_phi'])
        if len(crit_indices) > 0:
            x_crit = x_data[crit_indices]
            y_crit = results_hds['w_phi'][crit_indices]
            ax1.scatter(x_crit, y_crit, marker='o', s=80, facecolors='none', edgecolors='green',
                        zorder=5, label=r'Critical Points of $w_{\phi}$')
        
        crit_indices_camb = find_w_phi_critical_points(results_camb['w_phi'])
        if len(crit_indices_camb) > 0:
            x_crit_camb = x_data[crit_indices_camb]
            y_crit_camb = results_camb['w_phi'][crit_indices_camb]
            ax2.scatter(x_crit_camb, y_crit_camb, marker='o', s=80, facecolors='none', edgecolors='green',
                        zorder=5, label=r'Critical Points of $w_{\phi}$')

    if xlim: 
        ax1.set_xlim(xlim)
        ax2.set_xlim(xlim)
    if ylim: 
        ax1.set_ylim(ylim)
        ax2.set_ylim(ylim)
    else: ax1.set_ylim(-1.5, 1.2)

    ax1.set_xlabel(xlabel)
    ax1.set_ylabel("Equation of State (w)")
    ax2.set_xlabel(xlabel)
    ax2.set_ylabel("Equation of State (w)")

    if not use_redshift: 
        ax1.set_xscale('log')
        ax2.set_xscale('log')
    ax1.grid(True, which='both', linestyle='--', linewidth=0.5)
    ax2.grid(True, which='both', linestyle='--', linewidth=0.5)

    # --- Legend Handling ---
    handles, labels = ax1.get_legend_handles_labels()
    if show_initial_parameters:
        ic = results_hds['initial_conditions']
        ic_text = (
            f"Initial Conditions:\n"
            fr"$a_i = {ic['a_ini']:.1e}$"
            f"\n"
            fr"$\phi_i = {ic['phi_i']}$"
            f"\n"
            fr"$\phi'_i = {ic['phi_prime_i']} [Mpc^{-1}]$"
            f"\n"
            fr"$\alpha={global_alpha}$"
        )
        extra = Rectangle((0, 0), 1, 1, fc="w", fill=False, edgecolor='none', linewidth=0)
        handles.append(extra)
        labels.append(ic_text)

    ax1.legend(handles, labels, loc='upper right', fontsize=9, framealpha=0.9)

    plt.suptitle('Comparison of Dark Energy Equation of State: HDS vs CAMB', fontsize=16)
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])

def plot_relative_error(results_camb: Dict[str, Any],
                        results_hds: Dict[str, Any],
                        use_log_scale_y: bool = True,
                        quantities_to_compare: List[str] = ['w_eff', 'w_phi']) -> None:
    """
    Plots the relative error between HDS and CAMB results for a list of specified quantities.
    Relative Error = |(HDS - CAMB) / CAMB| * 100 (%)
    
    Args:
        results_camb: Dictionary of CAMB results.
        results_hds: Dictionary of HDS results.
        use_log_scale_y: Whether to use log scale for the y-axis.
        quantities_to_compare: List of keys to compare (e.g., ['w_eff', 'w_phi', 'phi', 'phi_prime']).
    """
    
    # Extract scale factor
    if 'a' not in results_hds:
        print("Error: Scale factor 'a' not found in results_hds.")
        return
    a = results_hds['a']
    
    # Setup Plot
    fig, ax = plt.subplots(figsize=(10, 6))
    epsilon = 1e-30  # To avoid division by zero
    
    plotted_any = False
    
    # Iterate over the requested quantities
    for qty in quantities_to_compare:
        # Check if quantity exists in both dictionaries
        if qty not in results_hds:
            print(f"Warning: Quantity '{qty}' not found in HDS results. Skipping.")
            continue
        if qty not in results_camb:
            print(f"Warning: Quantity '{qty}' not found in CAMB results. Skipping.")
            continue
            
        # Convert to numpy arrays to ensure element-wise operations work
        val_hds = np.array(results_hds[qty])
        val_camb = np.array(results_camb[qty])
        
        # Check for shape mismatch
        if val_hds.shape != val_camb.shape:
            print(f"Warning: Shape mismatch for '{qty}': HDS {val_hds.shape} vs CAMB {val_camb.shape}. Skipping.")
            continue
            
        # Calculate Relative Error (%)
        # Formula: |(HDS - CAMB) / CAMB| * 100
        rel_error = np.abs((val_hds - val_camb) / (val_camb + epsilon)) * 100
        
        # Create a formatted label for the legend
        # Tries to format variable names with underscores as LaTeX subscripts
        if '_' in qty:
            base, sub = qty.split('_', 1)
            label = fr"Error ${base}_{{{sub}}}$ (%)"
        else:
            label = f"Error ${qty}$ (%)"
            
        ax.plot(a, rel_error, label=label, linewidth=1.5)
        plotted_any = True
    
    if not plotted_any:
        plt.close(fig)
        print("No valid quantities were found to plot.")
        return
    
    # Styling
    ax.set_xlabel("Scale Factor (a)", fontsize=12)
    ax.set_ylabel(r"Relative Error (%) $\left| \frac{HDS - CAMB}{CAMB} \right| \times 100$", fontsize=12)
    
    # Create a title listing the quantities (truncated if too long)
    title_str = ", ".join(quantities_to_compare)
    if len(title_str) > 40:
        title_str = title_str[:37] + "..."
    ax.set_title(f"Relative Error: {title_str}", fontsize=14)
    
    ax.set_xscale('log')
    if use_log_scale_y:
        ax.set_yscale('log')
        
    ax.grid(True, which="both", ls="--", alpha=0.5)
    ax.legend(fontsize=12)
    
    plt.tight_layout()

def compare_results(results_camb: Dict[str, Any],
                    results_hds: Dict[str, Any], 
                    quantities: List[str] = ['w_phi', 'w_eff'],
                    show_phantom_crossings=True, 
                    show_critical_points=True,
                    xlim: Optional[List[float]] = None,
                    ylim: Optional[List[float]] = None,
                    use_redshift=False,
                    show_initial_parameters=True,
                    show_phantom_phase=True,
                    normalize_non_w: bool = True
                    ) -> None:
    """
    Plots specified quantities from both CAMB and HDS results for comparison.
    
    Args:
        quantities: List of keys to plot. e.g. ['w_phi', 'w_eff'] or ['phi', 'phi_prime'].
                    If quantities don't start with 'w', they are optionally normalized.
        normalize_non_w: If True, quantities not starting with 'w' are divided by their initial value.
    """
    logging.info(f"--- Plotting Results: {quantities} ---")
    
    # Determine if we are plotting Equations of State (to decide on grid lines/phases)
    plotting_w = any(q.startswith('w') for q in quantities)
    
    # --- Setup Figure ---
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7), sharey=True)
    
    # --- Setup X-axis ---
    if use_redshift:
        # Check if 'a' exists, handle potential division by zero
        a_hds = np.array(results_hds['a'])
        x_data = 1 / a_hds - 1
        xlabel = "Redshift (z)"
        ax1.invert_xaxis()
        ax2.invert_xaxis() 
    else:
        x_data = results_hds['a']
        xlabel = "Scale Factor (a)"
    
    # --- Style Definitions ---
    # Define styles for common variables to maintain consistency
    styles = {
        'w_phi':   {'color': '#1f77b4', 'ls': '-', 'label': r'$w_{\phi}$ (DE)'},
        'w_eff':   {'color': '#ff7f0e', 'ls': '--', 'label': r'$w_{eff}$'},
        'phi':     {'color': '#2ca02c', 'ls': '-', 'label': r'$\phi$'},
        'phi_prime': {'color': '#d62728', 'ls': '-.', 'label': r'$\phi^{\prime}$'},
        'rho_dm':  {'color': '#9467bd', 'ls': ':', 'label': r'$\rho_{dm}$'},
    }
    
    # Fallback color cycle for unknown quantities
    color_cycle = plt.rcParams['axes.prop_cycle'].by_key()['color']

    # --- Plotting Loop ---
    for ax, res, title in zip([ax1, ax2], [results_hds, results_camb], ['HDS Results', 'CAMB Results']):
        ax.set_title(title)
        
        for i, qty in enumerate(quantities):
            if qty not in res:
                logging.warning(f"Quantity {qty} not found in {title}")
                continue
            
            data = np.array(res[qty])
            
            # --- Normalization Logic ---
            # If it's not an EOS parameter and normalization is requested
            is_w = qty.startswith('w')
            is_normalized = False
            
            if not is_w and normalize_non_w:
                norm_factor = data[0] if data[0] != 0 else 1.0
                if norm_factor != 1.0:
                    data = data / norm_factor
                    is_normalized = True
            
            # --- Styling ---
            if qty in styles:
                style = styles[qty].copy()
                if is_normalized:
                    style['label'] = style['label'] + r' $/ \cdot_0$'
            else:
                # Generic style for unknown variables
                style = {
                    'color': color_cycle[i % len(color_cycle)], 
                    'ls': '-', 
                    'label': qty + (r' $/ \cdot_0$' if is_normalized else '')
                }

            # Plot
            ax.plot(x_data, data, label=style['label'], color=style['color'], linestyle=style['ls'], linewidth=2)

            # --- Special Features for w_phi ---
            if qty == 'w_phi' and show_critical_points:
                crit_indices = find_w_phi_critical_points(data)
                if len(crit_indices) > 0:
                    ax.scatter(x_data[crit_indices], data[crit_indices], 
                               marker='o', s=50, facecolors='none', edgecolors='green',
                               zorder=5) # No label to avoid clutter

    # --- Phantom Divide & Phase (Only if plotting w) ---
    if plotting_w:
        for ax, res in zip([ax1, ax2], [results_hds, results_camb]):
            ax.axhline(-1, color='gray', linestyle='-', linewidth=0.8, alpha=0.5, label='Phantom Divide' if 'Phantom Divide' not in [l.get_label() for l in ax.get_lines()] else "")
            
            if show_phantom_phase and 'w_eff' in res:
                w_eff = np.array(res['w_eff'])
                # Ensure masking works even if interpolation was slightly off
                mask_len = min(len(x_data), len(w_eff))
                ax.fill_between(x_data[:mask_len], w_eff[:mask_len], -1, 
                                where=w_eff[:mask_len] < -1, 
                                color='red', alpha=0.1)

    # --- Axes Formatting ---
    if xlim: 
        ax1.set_xlim(xlim)
        ax2.set_xlim(xlim)
    
    if ylim: 
        ax1.set_ylim(ylim)
    elif plotting_w:
        # Default for w plots
        ax1.set_ylim(-1.5, 1.2)
    
    ax1.set_xlabel(xlabel)
    ax2.set_xlabel(xlabel)
    
    # Smart Y-Label
    if plotting_w and len(quantities) == 2:
         ax1.set_ylabel("Equation of State (w)")
    elif normalize_non_w and not plotting_w:
         ax1.set_ylabel("Normalized Value ($X/X_0$)")
    else:
         ax1.set_ylabel("Value")

    if not use_redshift: 
        ax1.set_xscale('log')
        ax2.set_xscale('log')
    
    ax1.grid(True, which='both', linestyle='--', linewidth=0.5)
    ax2.grid(True, which='both', linestyle='--', linewidth=0.5)

    # --- Legend ---
    handles, labels = ax1.get_legend_handles_labels()
    
    # Remove duplicate labels if any
    by_label = dict(zip(labels, handles))
    
    # Add Initial Conditions box
    if show_initial_parameters:
        ic = results_hds.get('initial_conditions', {})
        if ic:
            # Attempt to get global alpha if not in ic
            alpha_val = ic.get('alpha', globals().get('global_alpha', '?'))
            
            ic_text = (
                f"Init Conds:\n"
                fr"$a_i = {ic.get('a_ini', 0):.1e}$" + "\n" +
                fr"$\phi_i = {ic.get('phi_i', 0):.2g}$" + "\n" +
                fr"$\alpha={alpha_val}$"
            )
            extra = Rectangle((0, 0), 1, 1, fc="w", fill=False, edgecolor='none', linewidth=0)
            by_label[ic_text] = extra

    ax1.legend(by_label.values(), by_label.keys(), loc='best', fontsize=9, framealpha=0.9)

    plt.suptitle(f'Comparison: {", ".join(quantities)}', fontsize=16)
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])

#compare_eos()
#plot_relative_error(results_camb_dict, results_HDS, quantities_to_compare=['w_eff', 'w_phi', 'phi', 'phi_prime'])
#compare_results(results_camb_dict, results_HDS, quantities=['phi', 'phi_prime'], normalize_non_w=True)
#plt.show()

print(results_HDS['phi_prime'])
print(results_camb_dict['phi_prime']) # there is a discrepancy on phi_prime
